---
output:
  html_document:
    css: style.css
---

# Assignment 6 {-}

## Problem Statement {-}
Plotting data is a useful but oftentimes complicated skill set. While R has many tools to help simplify and create attractive and useful graphs, they can be difficult to utilize and have many pitfalls. This assignment will teach you the most important parts of plotting with R using the package `ggplot`.

## Learning Objectives {-}
1. The basic operations of `ggplot` and "The Grammar of Graphics".
2. Using differential gene expression analysis packages to generate data for plotting.
3. Creating simple plots and **not** using the default colors and themes.
4. Combining multiple plots into one image and exporting them to disk.

## Skill List {-}
- A tempered heart and mind that understands a plot may not ever look _exactly_ how you want it to.
- An intermediate understanding of R's most popular plotting package, `ggplot`.
- Further understanding of differential expression analysis and its plotting.
- A sense of superiority whenever you see a publication use the base R plotting package for figures.

## Instructions {-}
Complete `main.R` in a way that satisfies all of the tests in `test_main.R`. Follow the instructions in the function descriptions for `main.R` and read here for details on the tests your code should satisfy. You will use these functions to complete figures in `report.Rmd`.

You can use `testthat:test_file('test_main.R')` in your R console to run all tests in `rest_main.R`. Do not modify the tests.

## Function Details {-}

### 1. `load_n_trim()` {-}
Once again we have some data to load into R in order to manipulate. We'll be loading a counts file, which is a matrix of genes (rows) by samples (columns). Each cell is the number of that gene found in that sample. This is a good opportunity to use a data frame or a tibble, but because of package restrictions we will be sticking to data frames for this assignment. We're using a couple different packages to process our data, and they input/output _exclusively_ in data frames, so we will be consistent and save ourselves some trouble with conversions.  

We want to return a data frame that is essentially identical to our input file (always a good idea to use the command line to see what you're working with). Ensure the gene names are stored as `row.names` and _not_ as a separate column, data frames have a distinction between the two. This function should also reduce the columns to just those of interest (P0 and Adult).

::: {.box .hint}
Row names can be changed using the `row.names()` function. The new row names must be a character vector of exactly the same length.
``` {r eval=FALSE}
df <- data.frame(a = c(0, 0, 0), b = c(1, 3, 5))
row.names(df) <- c("Row1", "Row2", "Row3")
print(df)
     a b
Row1 0 1
Row2 0 3
Row3 0 5
```
:::

#### Tests {-}
``` {r eval=FALSE}

test_that("test data is loading correctly and reduced", {
  test_df <- load_n_trim(csv)
  expect_equal(names(test_df), c("vP0_1", "vP0_2", "vAd_1", "vAd_2"))
  expect_equal(dim(test_df), c(55416, 4))
  expect_equal(class(test_df), "data.frame")
})
```
The tests for this assignment are relatively straightforward, mostly ensuring that data is loaded and ends up in the right shape and format. The first test ensures the columns were filtered, the second ensures the size is correct, and the final ensures it is a data frame and _not_ a tibble. No tibbles. Tible-less?

### 2. `run_deseq()` {-}
This is the first of three functions that technically do identical things (but in different ways). One of the most popular Bioconductor packages, DESeq2 has a number of options available for differential expression analysis. We will load in the counts data, select our variables of interest, and use `DESeq()` to process them. Links are included in the function description to DESeq2 documentation, you will find answers to most questions there, especially since those were the documents used to _write_ this assignment. This function will return the results of the analysis.

#### Tests {-}
``` {r eval=FALSE}
test_that("deseq2 function is returning correct results", {
  load("mock_counts_df.RData") # loads the counts_df object into env
  coldata <- data.frame(condition = rep(c("day4", "day7"), each=2),
                        type="paired-end")
  row.names(coldata) <- c("vP4_1", "vP4_2", "vP7_1", "vP7_2")
  expect_warning(deseq <- run_deseq(counts_df, 
                                    coldata, 
                                    10, "condition_day7_vs_day4"))
  expect_equal(dim(deseq), c(19127, 6))
  expect_equal(class(deseq)[1], "DESeqResults")
  expect_equal(c("pvalue", "padj") %in% names(deseq), c(TRUE, TRUE))
})
```
Less concerning for you all but writing tests for larger data sets and more complicated functions like this is...tricky. The problem is it can't be written like a script, we can't use the results from `load_n_trim()` to test _this_ function, because what if one fails independently of the other? So in this case, we create an RData object of correctly loaded data that works _even if_ `load_n_trim()` is absolutely broken. Also, in this case, we are using different sets to test this (days 4 and 7 instead of 0 and adult) so you can't just load the test data and say you wrote the code! That would be disingenuous of you, and being disingenuous is for after you graduate.

This test loads the sample data (a data frame of counts) and creates the `coldata` object according to DESeq2 specifications. We wrap the `run_deseq()` in `expect_warning()` because DESeq throws a warning when it performs an expected behavior: converting strings to factors (this is bad programming! this is not what warnings are for, the package is functioning as expected). We then do a similar series of tests: ensure the dimensions are correct, ensure the results object are from DESeq, and ensure that the column names we need are present.

### 3. `run_edger()` {-}
As mentioned in the previous function, this is the EdgeR implementation of running the differential expression analysis based on our counts file. Again, this function should follow roughly the portion of the documentation mentioned in the function description. EdgeR has a number of additional plotting functions (such as `plotMDS()`) you may like to include. These are optional but pretty fun to see if your data is working out as expected (similar days clustered close together and so on). You will return the _entire_ results object, no filtering necessary yet.

#### Tests {-}
``` {r eval=FALSE}
test_that("edger function is returning correct results", {
  load("mock_counts_df.RData")
  group <- factor(rep(c(1,2), each=2))
  edger_res <- run_edger(counts_df, group)
  expect_equal(names(edger_res), c("logFC", "logCPM", "PValue"))
  expect_equal(dim(edger_res), c(15026, 3))
})
```
Similar to the DESeq2 tests, we aren't necessarily looking for a carbon copy of the results. While the process _should_ be entirely deterministic, it is better to allow some wiggle room and merely look that the columns we're interested in are present and that the data has the right shape. Note that EdgeR doesn't perform a BH correction (the p-adjusted column is non-existant). It's either an option that's off by default or just not a feature! Not a problem, we have the p-values so we can do it ourselves later on.

### 4. `run_limma()` and `run_voom()` {-}
Our final in this set of three, we're testing two related functions in the Limma package. While you can create an analysis that _only_ uses Limma, in our case we can apply the **voom** workflow to refine our data a little more. More info on how these work in the cited documentation. A little technique that can be useful for optional workflows like this is including a boolean flag in the parameters of the function. If I am running a function `add_numbers(1, -4, abs=TRUE)`, the parameter `abs` might change the functions operation so that it takes the absolute value of numbers before adding them together. I could create this behavior like so:
``` {r eval=FALSE}
add_numbers <- function(x, y, abs=FALSE) {
  if (abs) { # code enters here if abs is TRUE
    return(abs(x) + abs(y)) # return means function exits, doesn't go to "else {}"
  } else { # code enters here if abs was false
    return(x + y)
  }
}
```
This is a very useful technique for re-using functions, meaning I don't need to write two functions that do similar things when I can change their behavior with that boolean parameter.

#### Tests {-}
``` {r eval=FALSE}
test_that("test limma + voom work + work together", {
  load("mock_counts_df.RData")
  group <- factor(rep(c(1,2), each=2))
  # design
  design <- data.frame(day4=1, day4vsday7=c(0, 0, 1, 1))
  row.names(design) <- c("vP4_1", "vP4_2", "vP7_1", "vP7_2")
  # limma
  limma_res <- run_limma(counts_df, design, voom=FALSE)
  expect_equal(dim(limma_res), c(1000, 6))
  expect_equal(names(limma_res), c("day4", "day4vsday7", "AveExpr", "F", 
                                   "P.Value", "adj.P.Val"))
  # voom
  dge <- DGEList(counts=counts_df, group=group)
  voom_res <- run_voom(dge, design)
  expect_equal(dim(voom_res), c(1000, 6))
  expect_equal(names(voom_res), c("logFC", "AveExpr", "t", "P.Value", 
                                  "adj.P.Val", "B"))
})
```
This is a longer series of tests but since we're considering two functions that is to be expected. It ultimately functions similarly to the first two series of tests: load test data, apply the function to it, make sure the results are the right size, shape, and type.  

::: {.box .note}
Note that Limma uses EdgeR to input data, so your first couple steps will look pretty familiar. 
:::

We create a design object to use, defining the experimental conditions. These are again using the day 4 and day 7 trials from the heart data. First, we test Limma by checking the dimensions of the results are **1,000** rows long. This differs from the first two examples, because Limma has a built-in method for controlling the number of results it returns. Your function (for both `run_limma` and `run_voom`) should end using `topTable(number=1000, resort.by = "p")`. This will return the top 1,000 rows, sorted by p-value ascending. The same test is done for voom, and the tests expect very similar results.

::: {.box .important}
`run_voom` should be used in `run_limma`, in the boolean-parameter-if-else structure I discuss above. This means that `run_voom` is _defined_ before or after `run_limma` is. This is okay, because `run_voom` only needs to be defined _when `run_limma`_ is run. 
:::
