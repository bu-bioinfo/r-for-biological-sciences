---
title: "Biology and Bioinformatics"
subtitle: "[R for Biological Science](../index.html)"
output: ioslides_presentation
author: "Adam Labadorf"
company: "Boston University"
---

```{r bioinfo setup, include=FALSE}
setwd('../')
source("0700_bioinfo.R")
source("setup_example_data.R")
setwd('slides')
library(tidyverse)
library(ggplot2)
```

## R in Biology

* R rose in popularity when [microarray
  technology](https://www.genome.gov/genetics-glossary/Microarray-Technology)
  came into widespread use
* A community of biological researchers and data analysts created a collection
  of software packages called [Bioconductor](https://www.bioconductor.org/)
* R packages form a bridge between:
  - biologists without a computational background and
  - statisticians and bioinformaticians, who invent new methods and implement
    the as R packages that are easily accessible by all

# Biological Data Overview

## Types of Biological Data

* There are five types of data used in biological data analysis:
  - raw/primary data
  - processed data
  - analysis results
  - metadata
  - annotation data

## Raw/primary data  

* The primary observations made by instruments/experiments
* Examples:
  - high-throughput sequencing data
  - mass/charge ratio data from mass spectrometry
  - 16S rRNA sequencing data from metagenomic studies
  - SNPs from genotyping assays,
* Often very large and not efficiently processed using R
* Specialized tools built outside of R are used to first process the
primary data into a form that is amenable to analysis
* The most common primary biological data types include [Microarrays], [High Throughput Sequencing] data,
and [mass spectrometry](https://en.wikipedia.org/wiki/Mass_spectrometry) data

## Processed data

* The result of any analysis or transformation of primary data into an intermediate, more interpretable form
* For example, in RNASeq:
  1. short reads aligned against a genome
  2. counted against annotated genes
  3. counts form counts matrix of genes x samples
* Processed data does not need to be stored long term if the raw data and code
  to produce it is available

## Analysis results

* Analysis results aren't data *per se* but are the results of analysis of
  primary data or processed data
* Usually what we use to form interpretations of our datasets
* Therefore we must manipulate them in much the same way as any other dataset

## Metadata

* Experiments usually study multiple samples
* Each sample typically has information associated with it
* "Data that is about data" is called *metadata*
* E.g. the information about human subjects included in a study including age at
  death, whether the person had a disease, the measurements of tissue quality,
  etc. is the metadata
* The primary and processed data and metadata are usually stored in
  different files, where the metadata (or *sample information* or *sample data*,
  etc) will have one column indicating the unique identifier (ID) of each sample.
* The processed data will typically have columns named for each of the sample IDs

## Annotation data

* Includes previously determined information about biological entities, e.g. genes
* Annotation data is publicly available information about the features we measure in our experiments
* Examples:
  - genomic coordinates where genes exist
  - any known functions of those genes
  - the domains found in proteins and their relative sequence
  - gene identifier cross references across different gene naming systems
  - single nucleotide polymorphism genomic locations and associations with traits or diseases

## Information flow in biological data analysis

<img src="../information_flow.png" width="80%"/>

# CSV Files

## CSV Files

* `csv` - character separated value file
* Most common, convenient, and flexible data file format in biology and bioinformatics
* Plain text files that contain rectangular data
* Each line of these files has some number of data values separated by a consistent character
  - most commonly the comma which are called [comma-separated value, or "CSV", files](https://en.wikipedia.org/wiki/Comma-separated_values)
* Filenames typically end with the extension `.csv`
* Other characters, especially the <Tab> character, may be used to create valid
files in this format

## Example CSV file

```
id,somevalue,category,genes
1,2.123,A,APOE
4,5.123,B,"HOXA1,HOXB1"
7,8.123,,SNCA
```

## Properties and principles of CSV files

* The first line often but not always contains the column names of each column
* Each value is delimited by the same character, in this case `,`
* Values can be any value, including numbers and characters
* When a value contains the delimiting character (e.g. HOXA1,HOXB1 contains a
  `,`), the value is wrapped in double quotes
* Values can be missing, indicated by sequential delimiters (i.e. `,,` or one
  `,` at the end of the line, if the last column value is missing)
* There is no delimiter at the end of the lines
* To be well-formatted *every line must have the same number of delimited
  values*

# Forms of Biological Data

## Common Biological Data Matrices

* *processed data* typically what we worked with in R
* Common features:
  - First row is column headers/sample names
  - First column is some *identifier* (gene symbol, genomic locus, etc)
  - Each row is a variable with sample values as columns

## Biological Data Matrix Example

```r
intensities <- readr::read_csv("example_intensity_data.csv")
intensities
# A tibble: 54,675 x 36
   probe     GSM972389 GSM972390 GSM972396 GSM972401 GSM972409
   <chr>         <dbl>     <dbl>     <dbl>     <dbl>     <dbl>
 1 1007_s_at      9.54     10.2       9.72      9.68      9.35
 2 1053_at        7.62      7.92      7.17      7.24      8.20
 3 117_at         5.50      5.56      5.06      7.44      5.19
 4 121_at         7.27      7.96      7.42      7.34      7.49
 5 1255_g_at      2.79      3.10      2.78      2.91      3.02
# ... with 54,665 more rows, and 26 more variables: GSM972433 <dbl>
#   GSM972487 <dbl>, GSM972488 <dbl>, GSM972489 <dbl>,
#   GSM972510 <dbl>, GSM972512 <dbl>, GSM972521 <dbl>
```

## Biological data is NOT Tidy!

* "tidy" data has the following properties:

  1. Each variable must have its own column
  2. Each observation must have its own row
  3. Each value must have its own cell

* Data from high throughput biological experiments have many more *variables*
  than *observations*!
* Biological data matrices are usually *transposed*
  - variables as rows
  - observations (i.e. samples) as columns

## Biological data is NOT Tidy!

```r
# A tibble: 54,675 x 36
   probe     GSM972389 GSM972390 GSM972396 GSM972401 GSM972409
   <chr>         <dbl>     <dbl>     <dbl>     <dbl>     <dbl>
 1 1007_s_at      9.54     10.2       9.72      9.68      9.35
 2 1053_at        7.62      7.92      7.17      7.24      8.20
```

##  Tidyverse works on tidy data

* Base R and tidyverse are optimized to perform computations on columns not rows
* Can perform operations on rows rather than columns, but code may perform poorly
* A couple options:

  * **Pivot into long format.**
  * **Compute row-wise statistics using `apply()`.**

    ```r
    intensity_variance <- apply(intensities, 2, var)
    intensities$variance <- intensity_variance
    ```

# Bioconductor

## Bioconductor

* [Bioconductor](https://www.bioconductor.org/) is an organized collection of
strictly biological analysis methods packages
* Hosted and maintained outside of [CRAN](https://cran.r-project.org/)
* Maintainers enforce [rigorous coding quality, testing, and documentation
standards](https://bioconductor.org/developers/package-guidelines/)
* Bioconductor is divided into roughly two sets of packages:
  - *core maintainer* packages
  - user contributed packages

## Bioconductor: Core maintainer packages

* Core maintainer packages define a set of common objects and classes e.g.:
  - [ExpressionSet class](https://www.bioconductor.org/packages/devel/bioc/vignettes/Biobase/inst/doc/ExpressionSetIntroduction.pdf)
in the [Biobase package](https://bioconductor.org/packages/release/bioc/html/Biobase.html))
* All Bioconductor packages must use these common objects and classes
* Ensures consistency among all Bioconductor packages

## Installing Bioconductor

* Bioconductor is itself a package called [BiocManager](https://www.bioconductor.org/install/)
* `BiocManager` must be installed prior to installing other Bioconductor packages
* To [install bioconductor] (note `install.packages()`):

  ```r
  if (!require("BiocManager", quietly = TRUE))
      install.packages("BiocManager")
  BiocManager::install(version = "3.16")
  ```

## Installing Bioconductor packages

```r
# installs the affy bioconductor package for microarray analysis
BiocManager::install("affy")
```

## Bioconductor package pages

![](affy_package_page.png){width=90%}

## Bioconductor documentation

* In addition, Biconductor provides three types of documentation:

  - [Workflow tutorials](https://bioconductor.org/packages/release/workflows/) on
    how to perform specific analysis use cases
  - [Package vignettes](https://bioconductor.org/help/package-vignettes/) for
    every package, provides worked example of how to use the package
  - Detailed, consistently formatted reference documentation that gives precise
    information on functionality and use of each package


## Base Bioconductor Packages & Classes

* Base Bioconductor packages define convenient data structures for storing and
  analyzing biological data
* The `SummarizedExperiment` class stores data and metadata for an experiment

## `SummarizedExperiment` Illustration

![](https://media.springernature.com/full/springer-static/image/art%3A10.1038%2Fnmeth.3252/MediaObjects/41592_2015_Article_BFnmeth3252_Fig2_HTML.jpg?as=webp){width=80%}

## `SummarizedExperiment` Details

* `SummarizedExperiment` class is used ubiquitously throughout the Bioconductor
  package ecosystem
* `SummarizedExperiment` stores:
  - Processed data (`assays`)
  - Metadata (`colData` and `exptData`)
  - Annotation data (`rowData`)

# Gene Identifiers

## Gene Identifier Systems

* First gene sequence determined in 1965 - [an alanine
tRNA in yeast](https://pubmed.ncbi.nlm.nih.gov/14263761/)
* Genes are distinct entities - how do we name them?
* In 1979, formal guidelines for human gene nomenclature proposal gave
  researchers a common vocabulary for genes
* In 1989,  Human Genome Organisation (HUGO), become HUGO Gene Nomenclature Committee (HGNC)
* HGNC remains the official body providing guidelines and gene naming authority
* HGNC gene names called *gene symbols*

## HGNC Gene Name Guidelines

1. Each gene is assigned a unique symbol, HGNC ID and descriptive name.
2. Symbols contain only uppercase Latin letters and Arabic numerals.
3. Symbols should not be the same as commonly used abbreviations
4. Nomenclature should not contain reference to any species or “G” for gene.
5. Nomenclature should not be offensive or pejorative.

## Gene Symbols

* Gene symbols are the most human-readable system for naming genes
* e.g. *BRCA1*, *APOE*, and *ACE2*
* Symbols are convenient for humans when reading, identifying, communicating about genes
* However, symbols may be ambiguous, and some genes have many synonymous symbols
* Other gene identifier systems evolved in parallel to address this ambiguity

## Gene symbol ambiguity: APOE

![](apoe_gene_card.png){width=100%}

## Human Gene Identifier Systems: Ensembl

* [Ensembl](https://www.ensembl.org/) Project genome browser and genome annotation
  database
* Assigns automatic, systematic ID called *Ensembl Gene ID* during genome
  annotation
* Ensembl Gene ID follows convention `ENSGNNNNNNNNNNN`, where `N` are numbers
  - e.g. APOE is `ENSG00000130203`
* Gene annotation is
* Supports *versions* of genes, e.g. `ENSG00000130203.10` where `.10` indicates this
  is the 10th updated version of this gene
* Previous versions maintained

## Ensembl Gene IDs for Non-humans

* Ensembl Gene IDs have organism-specific conventions:

```{r echo=FALSE, results='asis'}
library(knitr)
kable(tribble(
  ~`Gene ID Prefix`, ~Organism, ~Symbol, ~Example,
  "`ENSG`", "Homo sapiens", "HOXA1", "ENSG00000105991",
  "`ENSMUSG`", "Mus musculus (mouse)", "Hoxa1", "ENSMUSG00000029844",
  "`ENSDARG`", "Danio rario (zebrafish)", "hoxa1a", "ENSDARG00000104307",
  "`ENSFCAG`", "Felis catus (cat)", "HOXA1",  "ENSFCAG00000007937",
  "`ENSMMUG`", "Macaca mulata (macaque)", "HOXA1", "ENSMMUG00000012807",
))
```

## Other Identifier Systems

* Ensembl is not the only gene identifier system besides gene symbol
* Entrez Gene IDs (UCSC Gene IDs) used by the [NCBI Gene
  database](https://www.ncbi.nlm.nih.gov/gene) are unique integers for each gene
  in each organism
  - APOE in humans is `384`, in mouse `11816`
* Online Mendelian Inheritance in Man (OMIM) database has identifiers that look like
  `OMIM:NNNNN`, where each OMIM ID refers to a unique gene or human phenotype
  - APOE is `OMIM:107741`
* UniProtKB/Swiss-Prot are protein sequence databases
  - APOE is `P02649`

## Mapping Between Identifier Systems

* Often must map between identifier systems
* e.g. We have Ensembl Gene ID, but want gene symbols
* Ensembl provides [BioMart](https://www.ensembl.org/biomart/martview) that provides
  gene identifier mappings
* Mappings can be downloaded as CSV files
* Ensembl website has [helpful
  documentation](https://useast.ensembl.org/info/data/biomart/index.html) on how
  to use BioMart to download annotation data

## Biomart in Bioconductor: `biomaRt`

* Ensembl also provides [the `biomaRt` Bioconductor
package](https://useast.ensembl.org/info/data/biomart/biomart_r_package.html)
* Allows programmatic access to the same information directly from R
* There is [much more information in the Ensembl
  databases](https://useast.ensembl.org/info/genome/index.html) than gene
  annotation data that can be accessed via BioMart

## `biomaRt` Example

```r
# this assumes biomaRt is already installed through bioconductor
library(biomaRt)

# the human biomaRt database is named "hsapiens_gene_ensembl"
ensembl <- useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl")
```

## `biomaRt` Example

```r
# listAttributes() returns a data frame, convert to tibble
as_tibble(listAttributes(ensembl))
# A tibble: 3,143 x 3
   name                          description                  page        
   <chr>                         <chr>                        <chr>       
 1 ensembl_gene_id               Gene stable ID               feature_page
 2 ensembl_gene_id_version       Gene stable ID version       feature_page
 3 ensembl_transcript_id         Transcript stable ID         feature_page
 4 ensembl_transcript_id_version Transcript stable ID version feature_page
 5 ensembl_peptide_id            Protein stable ID            feature_page
 6 ensembl_peptide_id_version    Protein stable ID version    feature_page
 7 ensembl_exon_id               Exon stable ID               feature_page
 8 description                   Gene description             feature_page
 9 chromosome_name               Chromosome/scaffold name     feature_page
10 start_position                Gene start (bp)              feature_page
# ... with 3,133 more rows
```

## `biomaRt` Example

* `name` column provides programmatic name associated with the attribute
that can be used to retrieve that annotation information using the `getBM()`
function:

```r
# create a tibble with ensembl gene ID, HGNC gene symbol, and gene description
gene_map <- as_tibble(
  getBM(
    attributes=c("ensembl_gene_id", "hgnc_symbol", "description"),
    mart=ensembl
  )
)
```

## `biomaRt` Example

```r
gene_map
# A tibble: 68,012 x 3
   ensembl_gene_id hgnc_symbol description                                                               
   <chr>           <chr>       <chr>                                                                     
 1 ENSG00000210049 MT-TF       mitochondrially encoded tRNA-Phe ...
 2 ENSG00000211459 MT-RNR1     mitochondrially encoded 12S rRNA ...
 3 ENSG00000210077 MT-TV       mitochondrially encoded tRNA-Val ...
 4 ENSG00000210082 MT-RNR2     mitochondrially encoded 16S rRNA ...
 5 ENSG00000209082 MT-TL1      mitochondrially encoded tRNA-Leu ...
 6 ENSG00000198888 MT-ND1      mitochondrially encoded NADH:ubiquinone
 7 ENSG00000210100 MT-TI       mitochondrially encoded tRNA-Ile ...
 8 ENSG00000210107 MT-TQ       mitochondrially encoded tRNA-Gln ...
 9 ENSG00000210112 MT-TM       mitochondrially encoded tRNA-Met ...
10 ENSG00000198763 MT-ND2      mitochondrially encoded NADH:ubiquinone
# ... with 68,002 more rows
```

## Mapping Homologs

* Many organisms share evolutionarily conserved genes (i.e. homologs)
* `biomaRt` links identifiers by explicitly [connecting
  different biomaRt
  databases](https://bioconductor.org/packages/release/bioc/vignettes/biomaRt/inst/doc/accessing_ensembl.html#given-the-human-gene-tp53-retrieve-the-human-chromosomal-location-of-this-gene-and-also-retrieve-the-chromosomal-location-and-refseq-id-of-its-homolog-in-mouse.)
  with the `getLDS()` function:

  ```r
  human_db <- useEnsembl("ensembl", dataset = "hsapiens_gene_ensembl")
  mouse_db <- useEnsembl("ensembl", dataset = "mmusculus_gene_ensembl")
  orth_map <- as_tibble(
    getLDS(attributes = c("ensembl_gene_id", "hgnc_symbol"),
         mart = human_db,
         attributesL = c("ensembl_gene_id", "mgi_symbol"),
         martL = mouse_db
    )
)
```

## Mapping Homologs

```r
orth_map
# A tibble: 26,390 x 4
   Gene.stable.ID  HGNC.symbol Gene.stable.ID.1   MGI.symbol
   <chr>           <chr>       <chr>              <chr>     
 1 ENSG00000198695 MT-ND6      ENSMUSG00000064368 "mt-Nd6"  
 2 ENSG00000212907 MT-ND4L     ENSMUSG00000065947 "mt-Nd4l"
 3 ENSG00000279169 PRAMEF13    ENSMUSG00000094303 ""        
 4 ENSG00000279169 PRAMEF13    ENSMUSG00000094722 ""        
 5 ENSG00000279169 PRAMEF13    ENSMUSG00000095666 ""        
 6 ENSG00000279169 PRAMEF13    ENSMUSG00000094741 ""        
 7 ENSG00000279169 PRAMEF13    ENSMUSG00000094836 ""        
 8 ENSG00000279169 PRAMEF13    ENSMUSG00000074720 ""        
 9 ENSG00000279169 PRAMEF13    ENSMUSG00000096236 ""        
10 ENSG00000198763 MT-ND2      ENSMUSG00000064345 "mt-Nd2"  
# ... with 26,380 more rows
```

## Alternative: `AnnotationDbi`

* BioMart/biomaRt is not the only ways to map different gene identifiers
* [AnnotateDbi](https://bioconductor.org/packages/release/bioc/html/AnnotationDbi.html)
  provides gene identifier mapping independent of Ensembl
* Also includes identifiers from technology platforms, e.g. probe set IDs from [microarrays](#microarrays)
* Also allows comprehensive and flexible homolog mapping


# Microarrays

## Microarrays

<div class="columns-2">

![](../microarray_chip.png){width=80%}

* Microarrays: devices that measure relative abundance of DNA molecules
* Measure 1000s of DNA molecules simultaneously
* Molecules are selected *a priori* and "hard coded" onto the device

</div>

## Microarray Design

![](../microarray_design.png){width=100%}

## Types of Microarrays 

* Microarrays measure DNA
* Usually one microarray is generated for an individual sample
* Sample preparation method depends on target molecules 
  - DNA: e.g. genetic variants, the DNA itself is biochemically extracted
  - RNA abundance: RNA extracted then reverse transcribed to complementary DNA (cDNA)
  
## Microarray Terminology

* **probe** - short (~25nt) cDNA molecule complementary to portion of target transcript
* **probe set** - a set of probes that all target the same gene
* **flowcell** - the glass slide portion of device that has probes deposited on it

## Microarray Data Generation Process

![](../microarray_data_gen.png){width=100%}

# Gene Expression

## Gene Expression

* Gene expression: the process by which information from a gene is used in the
  synthesis of functional gene products that affect a phenotype.
* Gene expression studies are often focused on protein coding genes, there are many
other functional molecules, e.g. [transfer
RNAs](https://www.genome.gov/genetics-glossary/Transfer-RNA),
[lncRNAs](https://en.wikipedia.org/wiki/Long_non-coding_RNA), etc, that are
produced by this process. The gene expression process has many steps and
intermediate products, as depicted in the following figure:

## Gene Expression Process

* Specific parts of the genome code for genes
* Gene sequences *transcribed* into RNA molecules called *transcripts*
* In lower organisms (e.g. bacteria), RNA molecules passed directly to ribosomes
* In most higher organisms (i.e. eukaryotes):
  1. Initial transcripts, called *pre-messenger RNA (pre-mRNA) transcripts* are
  processed via splicing 
  2. Splicing removes certain parts of pre-mRNA (*introns*) and concatenates
  adjacent sequences (*exons*) together into *mature RNA (mRNA)*
  3. mRNA exported from nucleus to be translated at ribosomes 
  
## Gene Expression Process

![](../gene_expression_nature.jpg){width=80%}
 
## Gene Expression Measurements

* Measurements proportional to abundance (or copy number) of RNA transcripts
* Measurements are always non-negative
* Usually *relative* to some normalizing quantity
  - i.e. a value of zero does *not* mean gene is not expressed!
* Some methods (e.g. digital droplet PCR) can estimate absolute abundance
  (i.e. exact number of copies)

## Gene Expression Assays

* Many ways to measure the abundance of RNA transcripts

  - Light absorbance
  - [Northern blot](https://www.genome.gov/genetics-glossary/Northern-Blot) 
  - [quantitative polymerase chain reaction
  (qPCR)](https://www.thermofisher.com/blog/ask-a-scientist/what-is-qpcr/)
  - Oligonucleotide and microarrays
  - High throughput RNA sequencing (RNASeq)

# Gene Expression Data in Bioconductor

## Gene Expression Data in Bioconductor

* [SummarizedExperiment
container](https://bioconductor.org/packages/release/bioc/html/SummarizedExperiment.html)
 standard way to load and work with gene expression data in Bioconductor
This container requires the following information:

  - `assays` - one or more measurement assays (e.g. gene expression) in the form of a feature by sample matrix
  - `colData` - metadata associated with the samples (i.e. columns) of the assays
  - `rowData` - metadata associated with the features (i.e. rows) of the assays
  - `exptData` - additional metadata about the experiment itself, like protocol, project name, etc

## SummarizedExperiment Schematic

![](https://media.springernature.com/full/springer-static/image/art%3A10.1038%2Fnmeth.3252/MediaObjects/41592_2015_Article_BFnmeth3252_Fig2_HTML.jpg?as=webp){width=70%}

## Creating SummarizedExperiments

*  Many Bioconductor packages for specific types of data, e.g.
  [limma](#differential-expression--microarrays-limma) create SummarizedExperiment
  objects for you
* You may also create your own...

## Creating `SummarizedExperiment`s

```{r load summarizedexperiment, include=FALSE}
library(SummarizedExperiment)
intensities <- readr::read_delim("../example_intensity_data.csv",delim=" ")
rowData <- intensities["probeset_id"]
intensities <- as.data.frame(
  dplyr::select(intensities, -probeset_id)
)
rownames(intensities) <- rowData$probeset_id
colData <- tibble(
  sample_name=colnames(intensities),
  condition=sample(c("case","control"),ncol(intensities),replace=TRUE)
)
se <- SummarizedExperiment(
   assays=list(intensities=intensities),
   colData=colData,
   rowData=rowData
)
```


```r
# microarray expression dataset intensities
intensities <- readr::read_delim(
  "example_intensity_data.csv",delim=" "
)

# the first column of intensities tibble is the probesetId,
# extract to pass as rowData
rowData <- intensities["probeset_id"]

# remove probeset IDs from tibble and turn into a R dataframe
# so that we can assign rownames since tibbles don't support
# row names
intensities <- as.data.frame(
  select(intensities, -probeset_id)
)
rownames(intensities) <- rowData$probeset_id
```

## `SummarizedExperiment` cont'd

```r
# these column data are made up, but you would have a
# sample metadata file to use
colData <- tibble(
  sample_name=colnames(intensities),
  condition=sample(c("case","control"),ncol(intensities),replace=TRUE)
)

se <- SummarizedExperiment(
   assays=list(intensities=intensities),
   colData=colData,
   rowData=rowData
)
```

## `SummarizedExperiment` cont'd

```
se
## class: SummarizedExperiment
## dim: 54675 35
## metadata(0):
## assays(1): intensities
## rownames(54675): 1007_s_at 1053_at ... AFFX-TrpnX-5_at AFFX-TrpnX-M_at
## rowData names(1): probeset_id
## colnames(35): GSM972389 GSM972390 ... GSM972512 GSM972521
## colData names(2): sample_name condition
```

### Differential Expression Analysis

Differential expression analysis seeks to identify to what extent gene
expression is associated with one or more variables of interest. For example,
we might be interested in genes that have higher expression in subjects with a
disease, or which genes change in response to a treatment.

Typically, gene expression analysis requires two types of data to run: an
expression matrix and a *design matrix*. The expression matrix will generally
have features (e.g. genes) as rows and samples as columns. The design matrix is
a numeric matrix that contains the variables we wish to model and any covariates
or confounders we wish to adjust for. The variables in the design matrix then
must be encoded in a way that statistical procedures can understand. The full
details of how design matrices are constructed is beyond the scope of this book.
Fortunately, R makes it very easy to construct these matrices from a tibble with
the [`model.matrix()`
function](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/model.matrix).
Consider for the following imaginary sample information tibble that has 10 AD
and 10 Control subjects with different clinical and protein histology
measurements assayed on their brain tissue:

```{r}
ad_metadata
```

We might be interested in identifying genes that are increased or decreased in
people with AD compared with Controls. We can create a model matrix for this as
follows:

```{r model matrix}
model.matrix(~ condition, data=ad_metadata)
```

The `~ condition` argument is an an R
[forumla](https://rviews.rstudio.com/2017/02/01/the-r-formula-method-the-good-parts/),
which is a concise description of how variable should be included in the model.
The general format of a formula is as follows:

```
# portions in [] are optional
[<outcome variable>] ~ <predictor variable 1> [+ <predictor variable 2>]...

# examples

# model Gene 3 expression as a function of disease status
`Gene 3` ~ condition

# model the amount of tau pathology as a function of abeta pathology,
# adjusting for age at death
tau ~ age_at_death + abeta

# create a model without an outcome variable that can be used to create the
# model matrix to test for differences with disease status adjusting for age at death
~ age_at_death + condition
```

For most models, the design matrix will have an intercept term of all ones and
additional colums for the other variables in the model. We might wish to adjust
out the effect of age by including `age_at_death` as a covariate in the model:

```{r model matrix cov}
model.matrix(~ age_at_death + condition, data=ad_metadata)
```

The model matrix now includes a column for age at death as well. This model
model matrix is now suitable to pass to differential expression software
packages to look for genes associated with disease status.

As mentioned above, modern gene expression assays measure thousands of genes
simultaneously. This means each gene must be tested for differential expression
individually. In general, each gene is tested using the same statistical model,
so a differential expression analysis package will perform something equivalent
to the following:

```
Gene 1 ~ age_at_death + condition
Gene 2 ~ age_at_death + condition
Gene 3 ~ age_at_death + condition
...
Gene N ~ age_at_death + condition
```
Each gene model will have its own statistics associated with it that we must
process and interpret after the analysis is complete.

## Microarray Gene Expression Data

Four steps involved in analyzing gene expression microarray data:

1. **Summarization of probes to probesets**
2. **Normalization**
3. **Quality control**
4. **Analysis**

## Microarray Data

* Raw probe intensity data stored in CEL data files
* [`affy` Bioconductor
package](https://www.bioconductor.org/packages/release/bioc/html/affy.html)
  - Loads CEL files into Bioconductor objects
  - Performs key preprocessing operations
* Typically have many CEL files, one per each sample

## Reading CEL Files

* Load CEL files with `affy::ReadAffy` function

```r
# read all CEL files in a single directory
affy_batch <- affy::ReadAffy(celfile.path="directory/of/CELfiles")

# or individual files in different directories
cel_filenames <- c(
  list.files( path="CELfile_dir1", full.names=TRUE, pattern=".CEL$" ),
  list.files( path="CELfile_dir2", full.names=TRUE, pattern=".CEL$" )
)
affy_batch <- affy::ReadAffy(filenames=cel_filenames)
```

## Probe summarization and normalization

* `affy` package provides functions to perform probe summarization and normalization
* Robust Multi-array Average (RMA) state of the art method for normalization
* `affy::rma` function implements RMA, performs summarization and normalization
  of multiple arrays simultaneously

## Aside: R package data

* Some packages include data with the R functionality
* Load package data into your workspace with `data()` function

```r
library(affydata)
data(Dilution)
```

## RMA normalization

```{r microarray norm 1, include=F}
library(affy)
library(affydata)
data(Dilution)

# normalize the Dilution microarray expression values
# note Dilution is an AffyBatch object
eset_rma <- affy::rma(Dilution,verbose=FALSE)
```

```r
library(affy)
library(affydata)
data(Dilution)

# normalize the Dilution microarray expression values
# note Dilution is an AffyBatch object
eset_rma <- affy::rma(Dilution,verbose=FALSE)
```

## `ExpressionSet` vs `SummarizedExperiment`

* `ExpressionSet` is a container that contains high throughput assay data
* Similar to and superseded by `SummarizedExperiment`
* Some older packages (notably `affy`) return `ExpressionSet` objects, not
  `SummarizedExperiment`s
* Similar interface, but some key differences

| Operation | ExpressionSet | SummarizedExperiment |
|-----------|-----------------|------------------------|
| Get expression values | `exprs(eset)` | `assays(se)` |
| Get column data | `phenoData(eset)` | `colData(se)` |
| Get row data | `annotation(eset)` | `rowData(se)` |

## RMA normalization

```{r microarray norm 2, echo=F}
# plot distribution of non-normalized probes
# note rma normalization takes the log2 of the expression values,
# so we must do so on the raw data to compare
raw_intensity <- as_tibble(exprs(Dilution)) %>%
  mutate(probeset_id=rownames(exprs(Dilution))) %>%
  pivot_longer(-probeset_id, names_to="Sample", values_to = "Intensity") %>%
  mutate(
    `log2 Intensity`=log2(Intensity),
    Category="Before Normalization"
  )

# plot distribution of normalized probes
rma_intensity <- as_tibble(exprs(eset_rma)) %>%
  mutate(probesetid=featureNames(eset_rma)) %>%
  pivot_longer(-probesetid, names_to="Sample", values_to = "log2 Intensity") %>%
  mutate(Category="RMA Normalized")

dplyr::bind_rows(raw_intensity, rma_intensity) %>%
  ggplot(aes(x=Sample, y=`log2 Intensity`)) +
  geom_boxplot() +
  facet_wrap(vars(Category))
```

## Differential Expression: Microarrays (limma)

* [limma](https://bioconductor.org/packages/release/bioc/html/limma.html): `li`near `m`odels of `mi`croarrays
* Designed for analyzing microarray gene expression data
* One of the [top most
downloaded](https://bioconductor.org/packages/stats/) Bioconductor packages
* Supports arbitrarily complex experimental designs while maintaining strong statistical power
* Can perform reliable inference even with small sample sizes

## limma Example Setup

* limma requires:
  - `ExpressionSet` or `SummarizedExperiment` container
  - a design matrix

```r
# intensities is an example gene expression matrix that corresponds to our
# AD sample metadata of 10 AD and 10 Control individuals
ad_se  <- SummarizedExperiment(
  assays=list(intensities=intensities),
  colData=ad_metadata,
  rowData=rownames(intensities)
)

# define our design matrix for AD vs control, adjusting for age at death
ad_vs_control_model <- model.matrix(~ age_at_death + condition, data=ad_metadata)
```

## limma Example: fit model

```r
# now run limma
# first fit all genes with the model
fit <- limma::lmFit(
  assays(se)$intensities,
  ad_vs_control_model
)

# now better control fit errors with the empirical Bayes method
fit <- limma::eBayes(fit)
```

```{r limma fit, include=FALSE}
ad_vs_control_model <- model.matrix(~ age_at_death + condition, data=ad_metadata)

# now run limma
# first fit all genes with the model
fit <- limma::lmFit(
  assays(ad_se)$intensities,
  ad_vs_control_model
)

# now better control fit errors with the empirical Bayes method
fit <- limma::eBayes(fit)
```


## limma Results

* Look at top results using `limma::topTable()` function:

```{r}
# the coefficient name conditionAD is the column name in the design matrix
# adjust="BH" means perform Benjamini-Hochberg multiple testing adjustment
# on the nominal p-values from each gene test
# topTable only returns the top 10 results sorted by ascending p-value by default
topTable(fit, coef="conditionAD", adjust="BH")
```
