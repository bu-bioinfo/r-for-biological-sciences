---
title: "[Data Wrangling](../data-wrangling.html)"
subtitle: "R for Biological Science"
output: ioslides_presentation
author: "Adam Labadorf"
company: "Boston University"
---

``` {r include=FALSE}
library(tidyverse)
```

## The Tidyverse

* [The tidyverse](https://www.tidyverse.org/) is "an opinionated collection of R packages designed for data science."
* packages are all designed to work together
* tidyverse practically changes the R language into a data science language
* tidyverse uses a distinct set of coding conventions that lets it achieve
  greater expressiveness, conciseness, and correctness relative to the base R language


## Tidyverse Basics

* tidyverse is a set of packages that work together
* Load the most common tidyverse packages at the same time:

  ```r
  library(tidyverse)
  -- Attaching packages ---------- tidyverse 1.3.1 --
  v ggplot2 3.3.5     v purrr   0.3.4
  v tibble  3.1.6     v dplyr   1.0.7
  v tidyr   1.1.4     v stringr 1.4.0
  v readr   2.1.1     v forcats 0.5.1
  -- Conflicts ------------- tidyverse_conflicts() --
  x dplyr::filter() masks stats::filter()
  x dplyr::lag()    masks stats::lag()
  ```

## Default tidyverse packages

+-------------------------------------------+------------------------------------------------+
| Package                                   | Description                                    |
+===========================================+================================================+
| [ggplot2](https://ggplot2.tidyverse.org/) | Plotting using the grammar of graphics         |
+-------------------------------------------+------------------------------------------------+
| [tibble](https://tibble.tidyverse.org/)   | Simple and sane data frames                    |
+-------------------------------------------+------------------------------------------------+
| [tidyr](https://tidyr.tidyverse.org/)     | Operations for making data "tidy"              |
+-------------------------------------------+------------------------------------------------+
| [readr](https://readr.tidyverse.org/)     | Read rectangular text data into tidyverse      |
+-------------------------------------------+------------------------------------------------+
| [purrr](https://purrr.tidyverse.org/)     | Functional programming tools for tidyverse     |
+-------------------------------------------+------------------------------------------------+
| [dplyr](https://dplyr.tidyverse.org/)     | "A Grammar of Data Manipulation"               |
+-------------------------------------------+------------------------------------------------+
| [stringr](https://stringr.tidyverse.org/) | Makes working with strings in R easier         |
+-------------------------------------------+------------------------------------------------+
| [forcats](https://forcats.tidyverse.org/) | Operations for using categorical variables     |
+-------------------------------------------+------------------------------------------------+

## Importing Data

* [readr](https://readr.tidyverse.org/) package has functions to read in data
  from text files:

+--------------+--------------------------------------------------+
| Function     | Brief description/use                            |
+==============+==================================================+
| `read_csv`   | Delimiter: `,` - Decimal separator: `.`          |
+--------------+--------------------------------------------------+
| `read_csv2`  | Delimiter: `;` - Decimal separator: `,`          |
+--------------+--------------------------------------------------+
| `read_tsv`   | Delimiter: `<tab>` - Decimal separator: `.`      |
+--------------+--------------------------------------------------+
| `read_delim` | Delimiter: set by user  - Decimal separator: `.` |
+--------------+--------------------------------------------------+

## Note `readr` functions operate on zipped files

* Some CSV files can be very large and may be [compressed](https://computer.howstuffworks.com/file-compression.htm)
* the most common compression formats in data science and biology are
  [gzip](https://www.gnu.org/software/gzip/) and [bzip](http://www.bzip.org/).
* All the `readr` file reading functions can read compressed files directly, so
  you do not need to decompress them firs

## Writing tabular files

* Note that `readr` also has functions for [writing delimited
  files](https://readr.tidyverse.org/reference/write_delim.html):

+--------------+--------------------------------------------------+
| Function     | Brief description/use                            |
+==============+==================================================+
| `read_csv`   | Delimiter: `,` - Decimal separator: `.`          |
+--------------+--------------------------------------------------+
| `read_csv2`  | Delimiter: `;` - Decimal separator: `,`          |
+--------------+--------------------------------------------------+
| `read_tsv`   | Delimiter: `<tab>` - Decimal separator: `.`      |
+--------------+--------------------------------------------------+
| `read_delim` | Delimiter: set by user  - Decimal separator: `.` |
+--------------+--------------------------------------------------+

## The tibble

* Data in tidyverse organized in a special data frame object called a `tibble`

<pre class="codeblock">
  library(tibble)
  tbl <- tibble(
      x = rnorm(100, mean=20, sd=10),
      y = rnorm(100, mean=50, sd=5)
  )
  tbl
  # A tibble: 100 x 2
         x     y
     <dbl> <dbl>
   1 16.5   54.6
   2 14.4   54.3
   # ... with 98 more rows
</pre>

## The tibble is a data frame

* A `tibble` stores rectangular data that can be accessed like a data frame:

<pre class="codeblock">
  tbl$x
  [1] 29.572549 12.015877 15.235536 23.071761 32.254703 48.048651 21.905756
  [8] 15.511768 34.872685 21.352433 12.515230 23.608096  6.778630 12.342237
  ...
  tbl[1,"x"] # access the first element of x
  # A tibble: 1 x 1
      x
    <dbl>
  1  29.6
  tbl$x[1]
  [1] 29.57255
</pre>

## tibble column names

* `tibbles` (and regular data frames) typically have names for their columns
  accessed with the `colnames` function

<pre class="codeblock">
  tbl <- tibble(
      x = rnorm(100, mean=20, sd=10),
      y = rnorm(100, mean=50, sd=5)
  )
  colnames(tbl)
  [1] "x" "y"
</pre>

## Changing tibble column names

* Column names may be changed using this same function:

<pre class="codeblock">
  colnames(tbl) <- c("a","b")
  tbl
  # A tibble: 100 x 2
         a     b
     <dbl> <dbl>
   1 16.5   54.6
   2 14.4   54.3
  # ... with 90 more rows
</pre>

* Can also use `dplyr::rename` to rename columns as well:

<pre class="codeblock">
  dplyr::rename(tbl,
    a = x,
    b = y
  )
</pre>

## tibbles, data frames, and row names

* tibbles and dataframes also have row names as well as column names:

<pre class="codeblock">
  tbl <- tibble(
      x = rnorm(100, mean=20, sd=10),
      y = rnorm(100, mean=50, sd=5)
  )
  rownames(tbl)
  [1] "1" "2" "3"...
</pre>

* `tibble` support for row names is only included for compatibility with base R data frames
*  Authors of tidyverse believe row names are better stored as a normal column

## Constructing tibbles by hand

* tibble package allows creating simple tibbles with the `tribble()` function:

```{r}
gene_stats <- tribble(
    ~gene, ~test1_stat, ~test1_p, ~test2_stat, ~test2_p,
   "apoe", 12.509293,   0.1032,   34.239521,   1.3e-5,
   "hoxd1",  4.399211,   0.6323,   16.332318,   0.0421,
   "snca", 45.748431,   4.2e-9,    0.757188,   0.9146,
)
gene_stats
```

## Tidy Data

* tidyverse packages designed to operate with so-called "tidy data"
* the following rules make data tidy:

  1. Each variable must have its own column
  2. Each observation must have its own row
  3. Each value must have its own cell

* a *variable* is a quantity or property that every observation in our dataset has
* each *observation* is a separate instance of those variable
  - (e.g. a different sample, subject, etc)

## Example of tidy data

1. Each variable has its own column.
2. Each observation has its own row.
3. Each value has its own cell.

```{r}
gene_stats
```

## Tidy data illustration

![Tidy data - from R for Data Science](https://d33wubrfki0l68.cloudfront.net/6f1ddb544fc5c69a2478e444ab8112fb0eea23f8/91adc/images/tidy-1.png){width=100%}

## pipes

* We often must perform serial operations on a data frame
* For example:
  1. Read in a file
  2. Rename one of the columns
  3. Subset the rows based on some criteria
  4. Compute summary statistics on the result

## Base R serial manipulations

* In base R we would need to do this with assignments

  ```r
  # data_file.csv has two columns: bad_cOlumn_name and numeric_column
  data <- readr::read_csv("data_file.csv")
  data <- dplyr::rename(data, "better_column_name"=bad_cOlumn_name)
  data <- dplyr::filter(data, better_column_name %in% c("condA","condB"))
  data_grouped <- dplyr::group_by(data, better_column_name)
  summarized <- dplyr::summarize(data_grouped, mean(numeric_column))
  ```

## pipes with `%>%`

* A key `tidyverse` programming pattern is chaining manipulations of `tibble`s together
  by passing the result of one manipulation as input to the next
* Tidyverse defines the `%>%` operator to do this:  

  ```r
  data <- readr::read_csv("data_file.csv") %>%
        dplyr::rename("better_column_name"=bad_cOlumn_name) %>%
        dplyr::filter(better_column_name %in% c("condA","condB")) %>%
        dplyr::group_by(better_column_name) %>%
        dplyr::summarize(mean(numeric_column))
  ```

* The `%>%` operator passes the result of the function immediately preceding it as the first argument to the
next function automatically

## Arranging Data

* Often need to manipulate data in tibbles in various ways
* Such manipulations might include:
  - Filtering out certain rows
  - Renaming poorly named columns
  - Deriving new columns using the values in others
  - Changing the order of rows etc.
* These operations may collectively be termed *arranging* the data
* Many provided in the *[`dplyr` package](https://dplyr.tidyverse.org/)

## Arranging Data Example

* In the examples below, we will make use of the following made-up tibble

``` {r}
gene_stats
```

## `dplyr::filter()` - Pick rows out of a data set

* Consider the following tibble with made up gene information

```
## # A tibble: 4 x 4
##    hgnc_symbol  mean        p    padj
##    <chr>       <int>    <dbl>   <dbl>
##  1 HOX1A        5799 0.000910 0.00941
##  2 BRCA1         153 0.0272   0.0342
##  3 BRCA2         115 0.0228   0.0301
##  4 SNCA          495 0.00318  0.0123
```

## `dplyr::filter()` - Filter based on text values

* We can use `filter()` on the data frame to look for the genes BRCA1 and BRCA2

```r
de_genes %>% filter(hgnc_symbol == "BRCA1" | hgnc_symbol == "BRCA2")
## # A tibble: 2 x 4
##    hgnc_symbol  mean        p    padj
##    <chr>       <int>    <dbl>   <dbl>
##  1 BRCA1         153 0.0272   0.0342
##  2 BRCA2         115 0.0228   0.0301
```

## `dplyr::filter()` - Filter based on numeric values


* We can use `filter()` to restrict genes to those that are significant at `padj < 0.01`

```r
de_genes %>% filter(padj < 0.01)
## # A tibble: 1 x 4
##    hgnc_symbol  mean        p    padj
##    <chr>       <int>    <dbl>   <dbl>
##  1 HOX1A        5799 0.000910 0.00941
```

## `dplyr::mutate()` - Create new columns using other columns

* Sometimes we want to create new columns derived from other columns
* Example: [Multiple testing correction](https://en.wikipedia.org/wiki/Multiple_comparisons_problem)
* Adjusts nominal p-values to account for the number of tests that are significant simply bu chance
* [Benjamini-Hochberg or False Discovery Rate (FDR)](https://en.wikipedia.org/wiki/False_discovery_rate) procedure, a common procedure
* `p.adjust` function can perform several of these procedures, including FDR

## `dplyr::mutate()` - FDR example

``` {r}
dplyr::mutate(gene_stats,
  test1_padj=p.adjust(test1_p,method="fdr")
)
```

## `dplyr::mutate()` - FDR example

* You can create multiple columns in the same call to `mutate()`:

  ``` {r}
  gene_stats_mutated <- dplyr::mutate(gene_stats,
    test1_padj=p.adjust(test1_p,method="fdr"),
    test2_padj=p.adjust(test2_p,method="fdr")
  )
  gene_stats_mutated
  ```

## `dplyr::mutate()` - Deriving from multiple columns

* Here we create a column with `TRUE` or `FALSE` if either or both of the adjusted
  p-values are less than $0.05$:

  ```r
  dplyr::mutate(gene_stats_mutated,
    signif_either=(test1_padj < 0.05 | test2_padj < 0.05),
    signif_both=(test1_padj < 0.05 & test2_padj < 0.05)
  )
  ```

* `|` and `&` operators execute 'or' and 'and' logic, respectively

## `dplyr::mutate()` - using derived columns

* Columns created first in a `mutate()` call can be used in subsequent column definitions:

```r
dplyr::mutate(gene_stats,
  test1_padj=p.adjust(test1_p,method="fdr"), # test1_padj created
  test2_padj=p.adjust(test2_p,method="fdr"),
  signif_either=(test1_padj < 0.05 | test2_padj < 0.05), #test1_padj used
  signif_both=(test1_padj < 0.05 & test2_padj < 0.05)
)
```

## `dplyr::mutate()` - Modifying columns

* `mutate()` can also be used to modify columns in place
* Example replaces the values in the `gene` column with upper cased values

  ```r
  dplyr::mutate(gene_stats,
    gene=stringr::str_to_upper(gene)
  )
  ```

## `stringr` - Working with character values

* Base R does not have very convenient functions for working with character strings
* We must frequently manipulate strings while loading, cleaning, and analyzing datasets
* The [stringr package](https://stringr.tidyverse.org/) aims to make working with strings "as
easy as possible."
* Package includes many useful functions for operating on strings:
  - searching for patterns
  - mutating strings
  - lexicographical sorting
  - concatenation
  - complex search/replace operations
* [stringr documentation](https://stringr.tidyverse.org/reference/index.html) and the very helpful [stringr cheatsheet](https://github.com/rstudio/cheatsheets/blob/main/strings.pdf).

## `stringr` Example: upper case

* The function `stringr::str_to_upper()` with the `dplyr::mutate()` function to
  cast an existing column to upper case

  ``` {r}
  dplyr::mutate(gene_stats,
    gene=stringr::str_to_upper(gene)
  )
  ```

## Regular expressions

* Many operations in `stringr` package use [regular expression](https://en.wikipedia.org/wiki/Regular_expression) syntax
* A *regular expression* is a "mini" programming language that describes patterns in text
* Certain characters have special meaning that help in defining *search patterns* that
identifies the location of sequences of characters in text
* Similar to but more powerful than "Find" functionality in many word processors

## Regular expression example

* Consider the tibble with made up gene information:

```
## # A tibble: 4 x 4
##    hgnc_symbol  mean        p    padj
##    <chr>       <int>    <dbl>   <dbl>
##  1 HOX1A        5799 0.000910 0.00941
##  2 BRCA1         153 0.0272   0.0342
##  3 BRCA2         115 0.0228   0.0301
##  4 SNCA          495 0.00318  0.0123
```

* Used `filter()` on the data frame to look for BRCA1 and BRCA2  individually
* These gene names follow a pattern of BRCAX, where X is 1 or 2
* Can write a regular expression to represent this pattern

## Regular expression example

* [`stringr::str_detect()`](https://stringr.tidyverse.org/reference/str_detect.html)
  returns `TRUE` if the provided pattern matches the input and `FALSE` otherwise

```r
dplyr::filter(de_genes, str_detect(hgnc_symbol,"^BRCA[12]$"))
## # A tibble: 2 x 4
##    hgnc_symbol  mean        p    padj
##    <chr>       <int>    <dbl>   <dbl>
##  1 BRCA1         153 0.0272   0.0342
##  2 BRCA2         115 0.0228   0.0301
```

## Regular expression example

```r
dplyr::filter(de_genes, str_detect(hgnc_symbol,"^BRCA[12]$"))
```

* The argument `"^BRCA[12]$"` is a regular expression that searches for the
  following:

  - Gene name starts with `BRCA` (`^BRCA`)
  - Of those, include genes only if followed by either `1` or `2` (`[12]`)
  - Of those, match successfully if the number is last character (`$`)

## Regular expression syntax

* Regular expression syntax has certain characters with special meaning:
  - `.` - match any single character
  - `*` - match zero or more of the character immediately preceding the `*` `"", "1", "11", "111", ...`
  - `+` - match one or more of the character immediately preceding the `*` `"1", "11", "111", ...`
  - `[XYZ]` - match one of any of the characters between `[]` (e.g. `X`, `Y`, or `Z`)
  - `^`, `$` - match the beginning and end of the string, respectively

* There are more special characters as well, good tutorial is[RegexOne - regular expression tutorial](https://regexone.com/)

### `dplyr::select()` - Subset Columns by Name

Our `mutate()` operations above created a number of new columns in our tibble,
but we did not specify where in the tibble the new columns should go. Let's
consider the mutated tibble we created with all four new columns:

``` {r select mutate}
dplyr::mutate(gene_stats,
  test1_padj=p.adjust(test1_p,method="fdr"),
  test2_padj=p.adjust(test2_p,method="fdr"),
  signif_either=(test1_padj < 0.05 | test2_padj < 0.05),
  signif_both=(test1_padj < 0.05 & test2_padj < 0.05),
  gene=stringr::str_to_upper(gene)
)
```

From a readability standpoint, it might be helpful if all the columns that are
about each test were grouped together, rather than having to look at the end of
the tibble to find them.

The [`dplyr::select()`
function](https://dplyr.tidyverse.org/reference/select.html) allows you to pick
specific columns out of a larger `tibble` in whatever order you choose:

``` {r select stats}
stats <- dplyr::select(gene_stats, test1_stat, test2_stat)
stats
```

Here we have explicitly selected the statistics columns. dplyr also has [helper
functions](https://tidyselect.r-lib.org/reference/starts_with.html) that allow
for more flexible selection of columns. For example, if all of the columns we
wished to select ended with `_stat`, we could use the `ends_with()` helper
function:

``` {r}
stats <- dplyr::select(gene_stats, ends_with("_stat"))
stats
```

If you so desire, `select()` allows for the renaming of selected columns:

``` {r}
stats <- dplyr::select(gene_stats,
  t=test1_stat,
  chisq=test2_stat
)
stats
```

If we knew that these test statistics actually corresponded to some kind of
t-test and a $\chi$-squared test, naming the columns of the tibble appropriately
may help others (and possibly you) understand your code better.

We can use the `dplyr::select()` function to obtain our desired column order:

``` {r}
dplyr::mutate(gene_stats,
  test1_padj=p.adjust(test1_p,method="fdr"),
  test2_padj=p.adjust(test2_p,method="fdr"),
  signif_either=(test1_padj < 0.05 | test2_padj < 0.05),
  signif_both=(test1_padj < 0.05 & test2_padj < 0.05),
  gene=stringr::str_to_upper(gene)
) %>%
dplyr::select(
    gene,
    test1_stat, test1_p, test1_padj,
    test2_stat, test2_p, test2_padj,
    signif_either,
    signif_both
)
```

Now the order of our columns is clear and convenient. It is not necessary to
list the columns for each test statistic on the same line, but the author thinks
this makes the code easier to read and understand.

::: {.box .readmore}
* [R for Data Science - Select columns with `select()`](https://r4ds.had.co.nz/transform.html#select)
* [dplyr reference](https://dplyr.tidyverse.org/reference/index.html)
* [select helper functions](https://tidyselect.r-lib.org/reference/starts_with.html)
:::

### `dplyr::arrange()` - Order rows based on their values

Another common operation when working with biological analysis results is
ordering them by some meaningful value. Like above, p-values are often used to
prioritize results by simply sorting them in ascending order. The `arrange()`
function is how to perform this sorting in tidyverse:

``` {r}
stats_sorted_by_test1_p <- dplyr::arrange(gene_stats, test1_p)
stats_sorted_by_test1_p
```

::: {.box .note}
Note we are sorting by nominal p-value here, not adjusted p-value. In general,
sorting by nominal or adjusted p-value results in the same order of results. The
only exception is when, due to the way the FDR procedure works, some adjusted
p-values will be identical, making the relative order of those tests with the
same FDR meaningless. In contrast, it is very rare that nominal p-values will be
identical, and since they induce the same ordering of results, when sorting
analysis results there are advantages to using nominal p-value, rather than
adjusted p-value.
:::

In general, the larger the magnitude of the statistic, the smaller the p-value
(for two-tailed tests), so if we so desired we could induce a similar ranking by
arranging the data by the statistic in descending order:

``` {r}
# desc() is a helper function that causes the results to be sorted in descending
# order for the given column
dplyr::arrange(gene_stats, desc(abs(test1_stat)))
```

Here we first apply the base R `abs()` function to compute the absolute value of
the test 1 statistic and then specify that we want to sort largest first. Note
although we don't have any negative values in our dataset, we should not assume
that in general, so it is safer for us to be complete and add the absolute value
call in case later we decide to copy and paste this code into another analysis.
That's pretty much all there is to `arrange()`.

::: {.box .readmore}
* [R for Data Science - Arrange rows with`arrange()`](https://r4ds.had.co.nz/transform.html#arrange-rows-with-arrange)
* [dplyr `arrange()` reference](https://dplyr.tidyverse.org/reference/arrange.html)
:::

### Putting it all together

In the previous sections, we performed the following operations:

1. Created new columns by computing false discovery rate on the nominal p-values
   using the `dplyr::mutate()` and `p.adjust` functions
2. Created new columns that indicate the patterns of significance for each gene
   using `dplyr::mutate()`
3. Mutated the gene symbol case using `stringr::str_to_upper` and
   `dplyr::mutate()`
4. Reordered the columns to group related variables with `select()`
5. Filtered genes based on whether they have an adjusted p-value less than 0.05
   for either and both statistical tests using `dplyr::filter()`
6. Sorted the results by p-value using `dplyr::arrange()`

For the sake of illustration, these steps were presented separately, but
together they represent a single unit of data processing and thus might
profitably be done in the same R command using `%>%`:

``` {r}
gene_stats <- dplyr::mutate(gene_stats,
  test1_padj=p.adjust(test1_p,method="fdr"),
  test2_padj=p.adjust(test2_p,method="fdr"),
  signif_either=(test1_padj < 0.05 | test2_padj < 0.05),
  signif_both=(test1_padj < 0.05 & test2_padj < 0.05),
  gene=stringr::str_to_upper(gene)
) %>%
dplyr::select(
    gene,
    test1_stat, test1_p, test1_padj,
    test2_stat, test2_p, test2_padj,
    signif_either,
    signif_both
) %>%
dplyr::filter(
  test1_padj < 0.05 | test2_padj < 0.05
) %>%
dplyr::arrange(
  test1_p
)
gene_stats
```

This complete pipeline now contains all of our manipulations and our mutated
tibble can be passed on to downstream analysis or collaborators.

## Grouping Data

Sometimes we are interested in summarizing subsets of our data defined by some
grouping variable. Consider the following made-up sample metadata for a set of
individuals in an Alzheimer's disease (AD) study:

``` {r}
metadata <- tribble(
    ~ID, ~condition, ~age_at_death, ~Braak_stage, ~APOE_genotype,
  "A01",        "AD",            78,            5,       "e4/e4",
  "A02",        "AD",            81,            6,       "e3/e4",
  "A03",        "AD",            90,            5,       "e4/e4",
  "A04",   "Control",            80,            1,       "e3/e4",
  "A05",   "Control",            79,            0,       "e3/e3",
  "A06",   "Control",            81,            0,       "e2/e3"
)
```

This is a typical setup for metadata in these types of experiments. There is a
sample ID column which uniquely identifies each subject, a condition variable
indicating which group each subject is in, and clinical information like age at
death, Braak stage (a measure of Alzheimer's disease pathology in the brain),
and diploid APOE genotype (e2 is associated with reduced risk of AD, e3 is
baseline, and e4 confers increased risk).

An important experimental design consideration is to match sample attributes
between groups as well as possible to avoid confounding our comparison of
interest. In this case, age at death is one such variable that we wish to match
between groups. Although these values look pretty well matched between AD and
Control groups, it would be better to check explicitly. We can do this using
`dplyr::group_by()` to group the rows together based on condition and
`dplyr::summarize()` to compute the mean age at death for each group:

``` {r}
dplyr::group_by(metadata,
  condition
) %>% dplyr::summarize(mean_age_at_death = mean(age_at_death))
```

The `dplyr::group_by()` accepts a tibble and a column name for
a column that contains a categorical variable (i.e. a variable with discrete
values like AD and Control) and separates the rows in the tibble into groups
according to the distinct values of the column. The `dplyr::summarize()`
function accepts the grouped tibble and creates a new tibble with contents
defined as a function of values for columns in for each group.

From the example above, we see that the mean age at death is indeed different
between the two groups, but not by much. We can go one step further and compute
the standard deviation age range to further investigate:

``` {r}
dplyr::group_by(metadata,
  condition
) %>% dplyr::summarize(
  mean_age_at_death = mean(age_at_death),
  sd_age_at_death = sd(age_at_death),
  lower_age = mean_age_at_death-sd_age_at_death,
  upper_age = mean_age_at_death+sd_age_at_death,
)
```

Note the use of summarized variables defined first being used in variables
defined later. Now we can see that the age ranges defined by +/- one standard
deviation clearly overlap, which gives us more confidence that our average age
at death for AD and Control are not significantly different.

::: {.box .note}
We used +/- one standard deviation to define the likely mean age range above and
below the arithmetic mean for simplicity in the example above. The proper way to
assess whether these distributions are significantly different is to use an
appropriate statistical test like a t-test.
:::

Like other functions in `dplyr`, `dplyr::summarize()` has some helper functions
that give it additional functionality. One useful helper function is `n()`,
which is defined as the number of records within each group. We will add one
more column to our summarized sample metadata from above that reports the number
of subjects within each condition:

``` {r}
dplyr::group_by(metadata,
  condition
) %>% dplyr::summarize(
  num_subjects = n(),
  mean_age_at_death = mean(age_at_death),
  sd_age_at_death = sd(age_at_death),
  lower_age = mean_age_at_death-sd_age_at_death,
  upper_age = mean_age_at_death+sd_age_at_death
)
```

We now have a column with the number of subjects in each condition.

::: {.box .note}
Hadley Wickham is from New Zealand, which uses British, rather than American,
English. Therefore, in many places, both spellings are supported in the
tidyverse; e.g. both `summarise()` and `summarize()` are supported.
:::

::: {.box .readmore}
* [R for Data Science - Grouped summaries with `summarise()`](https://r4ds.had.co.nz/transform.html#grouped-summaries-with-summarise)
* [dplyr `summarise()` reference](https://dplyr.tidyverse.org/reference/summarise.html)
:::

## Rearranging Data

Sometimes the shape and format of our data is not the most convenient for
performing certain operations on it, even if it is [tidy](#tidy-data). Let's say
we are considering the range of statistics that were computed for all of our
genes in the `gene_stats` tibble, and wanted to compute the average statistic
over all genes for both tests. Recall our tibble has separate columns for each
test:

```{r}
gene_stats <- tribble(
    ~gene, ~test1_stat, ~test1_p, ~test2_stat, ~test2_p,
   "APOE",   12.509293,   0.1032,   34.239521,   1.3e-5,
  "HOXD1",    4.399211,   0.6323,   16.332318,   0.0421,
   "SNCA",   45.748431,   4.2e-9,    0.757188,   0.9146,
)
gene_stats
```

For convenience, we desire our output to be in table form, with one row per test
and the statistics for each test as columns. We could do this manually like so:

```{r}
tribble(
   ~test_name, ~min, ~mean, ~max,
   "test1_stat", min(gene_stats$test1_stat), mean(gene_stats$test1_stat), max(gene_stats$test1_stat),
   "test2_stat",  min(gene_stats$test2_stat), mean(gene_stats$test2_stat), max(gene_stats$test2_stat),
)
```

This gets the job done, but is clearly very ugly, error prone, and would require
significant work if we later added more statistics columns.

Instead of typing out the values we desire manually, we can *pivot* our tibble
using the `tidyr::pivot_longer()` function, so that the column values are placed
in a new column and the corresponding values are placed in yet another column.
This process is illustrated in the following figure:

![Pivot longer moves columns and values to two new columns](pivot_longer.png)

In the figure, the original tibble has genes along rows and samples as columns.
When the sample columns are pivoted, the value of each column name is placed in
a new column named "Sample" and repeated for as many rows there are in the
tibble. A second new column "Value" is populated with the corresponding values
that were in each column. The gene associated with each value is preserved and
repeated vertically until all the table columns and values have been pivoted.
This process of pivoting transforms the tibble into so called "long" form.

Returning to our `gene_stats` example, we can apply some operations to the
tibble to easily perform the summarization we did above in a much more
expressive manner:

```{r pivot gene stats}
long_gene_stats <- tidyr::pivot_longer(
  gene_stats,
  ends_with("_stat"),
  names_to="test",
  values_to="stat"
)
long_gene_stats
```

We see that now instead of having `X_stat` columns, the column names and their
values have been put into the `test` and `stat` columns, respectively. Now to
summarize the statistics for each test, we simply do a `group_by()` on the
`test` column and compute summaries on the `stat` column:

```{r}
long_gene_stats %>%
  dplyr::group_by(test) %>%
  dplyr::summarize(min = min(stat), mean = mean(stat), max = max(stat))
```

You may verify that the numbers are identical in this pivoted tibble as the one
we manually created earlier. This pivoting method will produce the desired
output regardless of the number of tests we include the table, so long as the
column names end in `"_test"`.

::: {.box .note}
The inverse of `pivot_longer()` is
[`pivot_wider()`](https://tidyr.tidyverse.org/reference/pivot_wider.html). If
you have variables gathered in single columns like that produced by
`pivot_longer()` you can reverse the process with this function to create a
tibble with those variables as columns.
:::

::: {.box .readmore}
* [Pivoting - R for Data Science](https://r4ds.had.co.nz/tidy-data.html#pivoting)
* [`pivot_longer()` reference](https://tidyr.tidyverse.org/reference/pivot_longer.html)
:::

## Relational Data

As mentioned in our section on [types of biological data](#bio-data-types), we
often need to combine different sources of data together to aid in
interpretation of our results. Below we redefine the tibble of gene statistics
from above to have properly capitalized gene symbols:

``` {r}
gene_stats <- tribble(
    ~gene, ~test1_stat, ~test1_p, ~test2_stat, ~test2_p,
   "APOE",   12.509293,   0.1032,   34.239521,   1.3e-5,
  "HOXD1",    4.399211,   0.6323,   16.332318,   0.0421,
   "SNCA",   45.748431,   4.2e-9,    0.757188,   0.9146,
)
gene_stats
```

Our gene identifiers in this data frame are [gene
symbols](https://en.wikipedia.org/wiki/Gene_nomenclature#Symbol_and_name) which,
while convenient for our human brains to remember, can change over time and have
many aliases (e.g. the APOE gene has also been called AD2, LDLCQ5, APO-E, and
ApoE4 as listed on its
[genecard](https://www.genecards.org/cgi-bin/carddisp.pl?gene=APOE)). This can
make writing code that refers to a specific gene difficult, since there are so
many possible names to look for. Fortunately, there are alternative gene
identifier systems that do a better job of maintaining stable, consistent gene
identifiers, one of the most popular being [Ensembl](https://www.ensembl.org/).
Ensembl gene IDs always take the form `ENSGNNNNNNNNNNN` where `N`s are digits.
These IDs are much more stable and predictable than gene symbols, and are
preferable when working with genes in code.

We wish to add Ensembl IDs for the genes in our `gene_stats` result to the
tibble as a new column. Now suppose we have obtained another file with cross
referenced gene identifiers like the following:

``` {r}
gene_map <- tribble(
    ~symbol,            ~ENSGID,                    ~gene_name,
     "APOE",  "ENSG00000130203",            "apolipoprotein E",
     "BRCA1",  "ENSG00000012048", "BRCA1 DNA repair associated",
    "HOXD1",  "ENSG00000128645",                 "homeobox D1",
     "SNCA",  "ENSG00000145335",             "synuclein alpha",
)
gene_map
```

Imagine that this file contains mappings for all ~60,000 genes in the human
genome. While it might be simple to look up our three genes in this file and
annotate manually, it is easier to ask `dplyr` to do it for us. We can do this
using the `dplyr::left_join()` function which accepts two data frames and the
names of columns in each that share common values:

``` {r}
dplyr::left_join(
    x=gene_stats,
    y=gene_map,
    by=c("gene" = "symbol")
)
```

Notice that the additional columns in `gene_map` that were not involved in the
join (i.e. `ENSG` and `gene_name`) are appended to the `gene_stats` tibble. If
we wanted to use pipes, we could implement the same join above as follows:

``` {r}
gene_stats %>% dplyr::left_join(
  gene_map,
  by=c("gene" = "symbol")
)
```

Under the hood, the `dplyr::left_join()` function took the values in
`gene_stats$gene` and looked for the corresponding row in `gene_map` with the
same value in in the `symbol` column. It then appends all the additional columns
of `gene_map` for the matching rows and returns the result. We have added the
identifier mapping we desired with only a few lines of code. And what's more,
this code will work no matter how many genes we had in `gene_stats` as long as
`gene_map` contains a mapping value for the values in `gene_stats$gene`.

But what happens if we have genes in `gene_stats` that don't exist in our
mapping? In the above example, we use a left join because we want to include
all the rows in `gene_stats` regardless of whether a mapping exists in
`gene_map`. In this case this was fine because all of our genes in `gene_stats`
had a corresponding row in the mapping. However, notice that in the mapping
there is an additional gene, [BRCA1](https://en.wikipedia.org/wiki/BRCA1) that
is not in our gene statistics tibble. If we reverse the order of the join,
observe what happens:

``` {r}
gene_map %>% dplyr::left_join(
  gene_stats,
  by=c("symbol" = "gene")
)
```

Now the order of the rows is the same as in `gene_map`, and the columns for our
missing gene BRCA1 are filled with `NA`. This is the left join at work, where
the record from `gene_map` is included regardless of whether a corresponding
value was found in `gene_stats`.

There are additional types of joins besides left joins. Right joins are simply
the opposite of left joins:


``` {r}
gene_stats %>% dplyr::right_join(
  gene_map,
  by=c("gene" = "symbol")
)
```

The result is the same as the left join on `gene_map` except the order of the
resulting columns is different.

Inner joins return results for rows that have a match between the two tibbles.
Recall our left join on `gene_map` included BRCA1 even though it was not found
in `gene_stats`. An inner join will not include this row, because no match in
`gene_stats` was found:

``` {r}
gene_map %>% dplyr::inner_join(
  gene_stats,
  by=c("symbol" = "gene")
)
```

One last type of join is the
[`dplyr::full_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.html)
(also sometimes called an outer join). As you may expect, a full join will
return all rows from both tibbles whether a match in the other table was found
or not.

### Dealing with multiple matches

In the example above, there was a one-to-one relationship between the gene
symbols in both tibbles. This made the joined tibble tidy. However, when a
one-to-many relationship exists, i.e. one gene symbol in one tibble has multiple
rows in the other, this can lead to what appears to be duplicate rows in the
joined result. Due to the relative instability of gene symbols, it is very
common to have multiple Ensembl genes associated with a single gene symbol. The
following takes a gene mapping of Ensembl IDs to gene symbols and identifies
cases where multiple Ensembl IDs map to a single gene symbol:

``` {r}
readr::read_tsv("../mart_export.tsv") %>%
  dplyr::filter(
    `HGNC symbol` != "NA" & # many unstudied genes have Ensembl IDs but no official symbol
    `HGNC symbol` %in% `HGNC symbol`[duplicated(`HGNC symbol`)]) %>%
  dplyr::arrange(`HGNC symbol`)
```

There are over 7,000 Ensembl IDs that map to the same gene symbol as another
Ensembl ID. That is more than 10% of all Ensembl IDs. So now let's create a new
`gene_stats` tibble with one of these gene symbols and join with the map to
see what happens:

``` {r}
gene_map <- readr::read_tsv("../mart_export.tsv")
gene_stats <- tribble(
    ~gene, ~test1_stat, ~test1_p, ~test2_stat, ~test2_p,
   "APOE",   12.509293,   0.1032,   34.239521,   1.3e-5,
  "HOXD1",    4.399211,   0.6323,   16.332318,   0.0421,
   "SNCA",   45.748431,   4.2e-9,    0.757188,   0.9146,
  "DEAF1",    0.000000,      1.0,           0,      1.0
) %>% left_join(gene_map, by=c("gene" = "HGNC symbol"))
gene_stats
```

Notice how there are two rows for the DEAF1 gene that have identical values
except for the `Stable Gene ID` column. This is a very common problem when
mapping gene symbols to other gene identifiers and there is no general solution
to picking the "best" mapping, short of manually inspecting all of the
duplicates and choosing which one is the most appropriate yourself (which
obviously is a huge amount of work). However, we do desire to remove the
duplicated rows. In this case, since all the values besides the Ensembl ID are
the same, effectively it doesn't matter which duplicate rows we eliminate. We
can do this using the `duplicated()` function, which returns `TRUE` for all but
the first row of a set of duplicated values:

``` {r}
filter(gene_stats, !duplicated(gene))
```

However, in general, you must be careful about identifying these types of
one-to-many mapping issues and also about how you mitigate them.

::: {.box .readmore}
* [R for Data Science - Relational Data](https://r4ds.had.co.nz/relational-data.html)
* [dplyr - mutate joins](https://dplyr.tidyverse.org/reference/mutate-joins.html)
:::
