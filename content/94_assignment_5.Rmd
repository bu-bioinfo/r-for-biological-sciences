---
title: "Assignment 5 - DESeq2"
output:
  html_document:
    css: style.css
---

# Assignment 5 {-}

For this assignment, we will be utilizing DESeq2, which is easily installed through Bioconductor.  Once installed, you may install DESeq2 or other applicable packages available through Bioconductor. The following code blocks provide basic instructions for how to install Bioconductor and DESeq2.

```{r load libraries, message=FALSE, warning=FALSE, eval=FALSE}

library('tidyverse')
library('DESeq2')
```

If you do not already have Bioconductor, you may use the next block of code to install Bioconductor.

```{r install bioconductor, eval=FALSE}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install(version = "3.14")
```

Or if you already have Bioconductor installed, you may use this simple command to install DESeq2 itself.

```{r install DESeq2, eval=FALSE}
BiocManager::install('DESeq2')
```

## Problem Statement {-}
One of the main questions asked by high throughput sequencing is whether some variable or condition (e.g. treatment/disease status) induces a measurable, distinguishable change. In the context of mRNAseq, we are interested in whether we can determine if genes or mRNA levels are differentially expressed (upregulated or downregulated) between two or more conditions and if we can relate these changes back to their biological phenotype either directly or indirectly.

## Learning Objectives {-}
1. Understand the methodology and rationale for how DESeq2 normalizes data, models counts, and performs differential expression
2. Perform differential expression analysis using DESeq2 and learn one method to analyze time course data
3. Understand how to do basic inspection and evaluation of differential expression (DE) results

## Skill List {-}
1. DESeq2
2. Basic diagnostic plots of DE results
3. High-quality figures and plots using R and ggplot

## DESeq2 Background
DESeq2 is a well validated and highly cited method for differential expression analysis of HTS data. The original paper describing the
methodology in more detail can be found here:

>Love, M.I., Huber, W. & Anders, S. Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2. Genome Biol 15, 550 (2014). >https://doi.org/10.1186/s13059-014-0550-8

We will link back to the original DESeq2 vignette at the head of each applicable section for reference. We strongly encourage you to read the associated documentation as it succinctly summarizes the important concepts and methodology underlying each step of the process. It also provides example code snippets and answers to many common questions regarding the usage of DESeq2 can already be found in this documentation.

Briefly, at its core, DESeq2 models read counts and tests for differential expression through negative binomial generalized linear models. DESeq2 normalizes count data by scaling by size factors calculated by the median-of-ratios method developed in the original publication for DESeq. For significance testing, DESeq2 performs a Wald test to generate p-values and these are adjusted for multiple testing correction through the Benjamini-Hochberg method.

## Generating a counts matrix
DESeq2 takes as input a counts matrix where genes correspond to rows and samples to columns. For one of the more common use cases of differential expression analysis, mRNAseq experiments, we are interested in counts associated with genes; however, DESeq2 is broadly applicable to many kinds of high-throughout sequencing (HTS) count data.

Returning to the analysis of mRNAseq specifically, there are three main approaches to map reads:

1. Alignment to a reference genome by a splice-aware aligner and counting of reads falling into exonic regions using a reference
annotation file
2. Transcript-based assembly approaches (TopHat, Cufflinks) or transcript abundance quantification (Salmon, Kallisto)
3. Reference free assembly followed by mapping and counting

DESeq2 expects the values of the input matrix to be counts (integers) and for the purposes of this assignment, you have been provided with a count matrix of samples generated by the first method. Reads were aligned to the mouse genome (GENCODE GRCm39) with STAR and quantified to gene counts by Verse using the matching GTF file.

## Prefiltering Counts matrix
[DESeq2 Vignette - Pre-filtering](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#pre-filtering)

Unless your experiment is quite large, filtering your counts matrix prior to DESeq2 is not strictly required. If your experiment incorporates hundreds of samples and a complicated model design with many interaction terms, you may wish to perform a combination of manual filtering and further optimization of DESeq2 settings. Otherwise, for most datasets, default settings in DESeq2 will run in a reasonably short amount of time on relatively modest hardware even without pre-filtering.

There are many different strategies to filter count datasets and which you choose to employ should be informed by your objective, and your data. Some common filters include removing genes where the mean count across all samples is below some threshold or removing genes based on how many samples have a zero count. In general, extensive pre-filtering is not required and DESeq2 incorporates downstream methods to increase statistical power through independent filtering (described in methods). __For this assignment, we will not be filtering the dataset prior to running DE analysis.__

## Median-of-ratios normalization

As mentioned earlier, DESeq2 expects a non-transformed, non-normalized matrix of integer "counts" as input. DESeq2 performs its own normalization based on the underlying assumption that not all or a small amount of genes are truly differentially expressed. This is encapsulated in the median-of-ratios method which accounts for library size as well as RNA composition. Although DESeq2 performs this normalization in the background, it can help conceptually to understand the process by which it does so.

First, a pseudo-reference sample is created and set equal to the geometric mean across all samples for a given gene. Then, ratios are calculated comparing each sample to this pseudo-reference on gene-wise basis. Next, on a sample-wise basis, the median value for all ratios is taken as that sample's normalization factor and for a given sample, all counts are divided by this factor.

## DESeq2 preparation
[DESeq2 Vignette - Preparation](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#count-matrix-input)

The DESeqDataSet is the object that holds the read counts and associated statistical measures generated through the DESeq2 algorithm. Although there are several ways to generate this object, we will focus on the DESeqDataSetFromMatrix method which takes as input counts generated from an external pipeline. This method requires the aforementioned counts matrix, sample data information as a data frame, and the design formula.

## Oâ€™Meara et al. Transcriptional Reversion of Cardiac Myocyte Fate During Mammalian Cardiac Regeneration. Circ Res. Feb 2015. PMID: 25477501l

The counts matrix provided was generated by data made available by the listed publication. We have only taken a subset of their samples, focusing specifically on the experiment analyzing mRNAseq during *in vivo* heart development from 0, 4, 7 days after birth as well as in adult mice.

To start, we are going to consider the simplest use case for differential expression and subset our data to contain only the samples from postnatal day 0 and adult hearts. In addition to subsetting the counts matrix, we also need to construct the sample data information as a dataframe that lists the samplenames (columns in our counts matrix) as well as their associated information (in our case, timepoint).

We will use this as a demonstration of one of the simplest use cases for DESeq2, comparing two groups of samples based on a single experimental variable. Using what you've learned, __reshape the count matrix to only include the samples vP0 and vAD__.

Also, while possible to manually create a table of sample data, it can often be helpful in larger experiments and for better reproducibility to generate one from an existing metadata file that stores additional information about sample names, file names, and other categorical data. __Use the provided metadata csv to generate a sample dataframe compatible with DESeq2.__

::: {.box .hint}
Hint #1: You may ignore most of the columns in the metadata csv as they were used in the generation of the matrix itself. Focus on the samplenames and timepoints columns.

Hint #2: The columns (sample names) in your counts matrix and sample dataframe need to be in the same order

Hint #3: Your matrix and associated sample dataframe should look something like the below examples:
:::

```{r DESeq2 preparation, echo=FALSE}
counts <- read.table('verse_counts.tsv', header=TRUE, row.names='gene')
subset <- counts[, c('vP0_1', 'vP0_2', 'vAd_1', 'vAd_2')]
head(subset)
```

```{r function to prepare colData and matrix, echo=FALSE}
samplenames <- colnames(subset)
conditions <- c(rep('p0', 2), rep('AD', 2))
conditions <- as.factor(conditions)
coldata <- data.frame(samplenames, conditions)
coldata
```

```{r coldata from metadata csv, echo=FALSE, eval=FALSE}
make_coldata_subset <- function(metadata, c1, c2) {
coldata <- data.frame(readr::read_csv(metadata) %>% select(samplename, timepoint) %>% filter(timepoint %in% c(c1, c2)) %>% mutate_at(vars(timepoint), factor))
}

coldata <- make_coldata_subset('sample_metadata.csv', 'vP0', 'vAd')
```

## Factor Levels
[DESeq2 Vignette - Factor Levels](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#note-on-factor-levels)

The factor level in DESeq2 determines which level represents the "control" group you want to compare against. By default, the reference level for factors will be chosen alphabetically. You can either manually change and set the reference factor level or specify a comparison of interest using DESeq2 Contrast() after performing the first steps of the DE analysis.


## Performing DE Analysis
[DESeq2 Vignette](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html)

__Using the counts matrix and sample dataframe, perform a standard DESeq2 analysis comparing the two vAD samples vs the two vP0 samples. Look at the DESeq2 vignette for specific code on how to do this. You should obtain a dataframe that contains your differential expression results sorted by ascending adjusted p-value.__


```{r Running DESeq2, echo=FALSE, eval=FALSE}
dds <- DESeqDataSetFromMatrix(countData=subset, colData=coldata, design = ~ timepoint)
dds$timepoint <- relevel(dds$timepoint, ref='vP0')
dds <- DESeq(dds)

res <- results(dds, contrast=c('timepoint', 'vAd', 'vP0'))
res_ordered <- res[order(res$padj),]

```

```{r write results, eval=FALSE, echo=FALSE}

write.table(as.data.frame(res_ordered), file='verse_de_ad_d0.tsv', sep='\t', quote=FALSE)

```


## P-value distribution and multiple test correction
Separate from differential expression analysis, it is always an important diagnostic to plot the unadjusted distribution of p-values obtained from an experiment. Built-in to the definition of a p-value is the idea that under the null distribution and given all other assumptions made are true, p-values follow a uniform distribution. In general you should typically observe a peak of values close to 0 and a roughly uniform distribution as you approach 1. The values closer to 0 will be a mix of situations where the alternative hypothesis is true as well as potential false positives. Significant deviations from this general pattern likely require close examination of your data and the significance test you are employing. __Using your DE results and ggplot, make a histogram of the unadjusted p-values obtained from your DE results. Observe the shape of the distribution.__

## Choice of FDR cutoff depends on cost
The choice of a FDR cutoff or any p-value cutoff is always subjective and based on the objectives of your experiment and the cost of false discoveries. For example, if your initial sequencing experiment is exploratory and meant to generate hypotheses to be followed up *in vitro* or *in vivo*, it may be more appropriate to set a permissive cutoff (FDR < .20). FDR thresholds are set on an experiment by experiment basis and should not be adjusted simply to increase or decrease the number of DE genes retroactively.

```{r p-value distribution, echo=FALSE, eval=FALSE}
res_labeled %>% ggplot(aes(pvalue)) + geom_histogram(bins=50, color='black', fill='lightblue') + theme_linedraw() + ggtitle('Histogram of raw pvalues obtained from DE analysis') + theme(plot.title = element_text(hjust = 0.5))


```

```{r biomart, echo=FALSE, eval=FALSE}

gene_ids <- res_labeled %>% separate(genes, c('id', 'revision')) %>% dplyr::select(id) %>% base::list()
mart = useMart(biomart='ensembl', dataset='mmusculus_gene_ensembl')
mapping <- getBM(values=gene_ids, filters='ensembl_gene_id', mart=mart, attributes=c('ensembl_gene_id', 'mgi_symbol'))

```

## Histogram of Log Fold Changes
It is often helpful visualize the log2FoldChanges for your DE genes to gain a sense for how genes are changing on a global level. __Set a FDR cutoff of .10 and plot a histogram of the associated Log2FoldChanges for the significantly DE genes.__

```{r histogram of log2Foldchanges, echo=FALSE, eval=FALSE}
res_labeled %>% filter(padj < .1) %>% ggplot(aes(log2FoldChange)) + geom_histogram(bins=100, color='black', fill='light blue') + theme_linedraw() + theme(plot.title = element_text(hjust = 0.5)) + ggtitle('Histogram of Log2FoldChanges for DE Genes')


```

## Make a volcano plot
A volcano plot is a common data plot that is intended to quickly display points of interest by plotting statistical significance against a magnitude of change. In the specific case of mRNAseq differential expression data, this entails plotting the log(p-values / corrected p-values) against the estimated log fold changes reported by most differential expression methods.

Statistically significant genes with low p-values will appear higher on the y-axis of the plot and they will be separated by the magnitude and directionality of their change (i.e. More highly upregulated genes will be further along to the right on the x-axis, and the converse for downregulated genes). Typically, genes of interest that have additional biological relevance to the experiment will be directly annotated using domain knowledge.

 __Using a FDR cutoff of .1, make a volcano plot of Log2FoldChange vs. -Log10(padj) for the results you generated. Label the points by the directionality of their change (sign of Log2FoldChange) and their significance.__

*Hint #1: Remember the color (colour) argument in geom_point*

*Hint #2: The labels will encompass three groups: 1. Positive log fold change and significant, 2. Negative log fold change and significant, 3. Remaining non-significant genes*

```{r label significant up and down regulated genes using case_when, echo=FALSE, eval=FALSE}
res_labeled <- res_ordered %>%
  as.data.frame() %>%
  as_tibble(rownames='genes') %>%
  mutate(volc_plot_status = case_when(log2FoldChange > 0 & padj < .10 ~ 'Up',
                                      log2FoldChange < 0 & padj < .10 ~ 'Down',
                                      TRUE ~ 'NS'))
```

```{r plot Volcano plot, echo=FALSE, eval=FALSE}
res_labeled %>% ggplot() + geom_point(mapping=aes(x=log2FoldChange, y=-log10(padj), color=volc_plot_status)) + geom_hline(yintercept = -log10(0.1), linetype = "dashed")  + theme_linedraw()

```

## A warning about *post hoc* filtering by fold change
After obtaining a list of differential expression results, it is important to remember that the fold change value is an estimate and the associated p-values were calculated  testing for whether or not the log2fold change differed significantly from zero. It is therefore not appropriate to simply filter genes above (below) a given fold change value threshold. Instead, if you wish to say with some statistical certainty that a fold change value is above (below) some threshold, you should incorporate it directly into the testing methodology (DESeq2 has a flagged option for this).

It is important to give careful thought as to whether to set a LfcThreshold in DESEQ2. It is a far more conservative test and will give you far fewer DE genes. One consideration for using a LfcThreshold in your experiment is if the treatment / condition is expected to induce a very large number of DE genes and you wish to return those that respond in magnitude most strongly.

```{r example LfcThreshold code, eval=FALSE}
res_lfcthreshold <- results(your_dds_object_here, contrast=c('timepoint', 'vAd', 'vP0'), lfcThreshold=0.585, altHypothesis="greaterAbs")
```

Keep in mind it's a log2Fold change threshold so the value above would correspond to a test for fold changes above 1.5 (2^.585). This threshold value should be set conservatively as it is a much more stringent statistical test.

## Visualize normalized counts for top ten DE genes

It can be helpful to visualize the normalized counts for a few differentially expressed genes as a quick check that things are working as intended. You may extract the counts normalized by the calculated size factors using the following code:

```{r top ten DE genes, echo=FALSE, eval=FALSE}
top_ten <- res_labeled %>% top_n(-10, padj) %>% dplyr::select(genes)
```

```{r extract normalized counts, eval=FALSE}
norm_counts <- counts(your_dds_object_here, normalized=T)
```

__Using the matrix of DE results you generated in the previous steps, extract out the normalized counts for the top ten DE genes (as ranked by ascending padj) and plot their normalized counts as a scatter plot labeling by sample or timepoint.__

::: {.box .hint}
Hint #1: If you are plotting all of the genes on the same plot, you may find it helpful to take the logarithm of the counts as different genes often have counts that differ by several orders of magnitude.

Hint #2: You may find it helpful to add a slight horizontal "jitter" to the points to aid in visualization for cases where counts for each replicate are similar.
:::

```{r plot normalized counts, echo=FALSE, eval=FALSE}
norm_counts_tb <- norm_counts %>% as_tibble(rownames='genes')
top_ten %>% left_join(norm_counts_tb, by='genes') %>% gather(samplenames, norm_counts, -genes) %>% ggplot() + geom_point(aes(x=genes, y=log10(norm_counts), color=samplenames), position=position_jitter(w=0.1,h=0)) + theme_linedraw() + theme(axis.text.x=element_text(angle=90, hjust=1)) + ggtitle('Plot of Log10(normalized counts) for top ten DE genes')


```

## Time series with DESeq2 LRT
There are many ways to analyze time-series data from HTS experiments and for simplicity, we will discuss one such method implemented in DESeq2: the likelihood ratio test (LRT). Conceptually, the LRT implemented within DESeq2 tests whether a full model explains more deviance than a reduced model with terms of interest removed. For our specific data, we will use this to test to determine genes that are changing over time. We will consider our full model to be ~ timepoint versus the reduced model of ~1. Here we will use the full data matrix, so generate a new sample dataframe and DDS object using the full matrix of counts.

Important to note that the LFC generated by this test are not meaningfully interpretable. As well, the p-values are only applicable to the test of whether or not the gene is changed at any time point. __Use the DESeq2 vignette to perform a LRT analysis to determine genes that are DE at any time point__

```{r lrt results, echo=FALSE, eval=FALSE}

make_coldata <- function(metadata) {
  data.frame(readr::read_csv(metadata) %>% select(samplename, timepoint) %>% mutate_at(vars(timepoint), factor))
}

coldata_full <- make_coldata('sample_metadata.csv')
```


```{r Time Series LRT, echo=FALSE, eval=FALSE}

dds_lrt <- DESeqDataSetFromMatrix(countData=counts, colData=coldata_full, design = ~timepoint)
dds_lrt$timepoint <- relevel(dds_lrt$timepoint, ref='vP0')
dds_lrt <- DESeq(dds_lrt, test="LRT", reduced=~1)

res_lrt <- results(dds_lrt)
res_lrt_ordered <- res_lrt[order(res_lrt$padj),]
```

```{r results for LRT, echo=FALSE, eval=FALSE}
res_lrt_ordered
```


## Plotting the normalized counts over time for the top DE gene from the LRT analysis
In order to gain a sense for what it means for a gene to be DE at any time point, let us again use the normalized counts to visualize the expression profile over time. __Take the DE gene with the lowest adjusted p-value and extract the normalized counts for each timepoint. Make a scatterplot of the normalized counts for each replicate and each timepoint.__
::: {.box .hint}
Hint #1: You may extract out the normalized counts matrix as before or look in the DESeq2 vignette for built-in functions...*
:::

__Why is this gene considered to be changed over time? What will the expression profile of other genes called DE by the LRT analysis look like?__

```{r norm counts over time, echo=FALSE, eval=FALSE}
level_order <- c('vP0', 'vP4', 'vP7', 'vAd')
top_time <- plotCounts(dds_lrt, which.min(res_lrt$padj), intgroup=c('samplename', 'timepoint'), returnData=TRUE)
top_time %>% ggplot() + geom_point(aes(x= factor(timepoint, level=level_order), y=count, color=samplename), position=position_jitter(w=0.1,h=0)) + labs(x='Timepoint') + theme_linedraw() + ggtitle('Normalized counts over time for top DE gene from LRT analysis')
```


```{r test, eval=FALSE, echo=FALSE}


res_p7_v_p0 <- results(dds_lrt, contrast = c( "timepoint", "vP7", "vP0" ), test='Wald')
res_p7_v_p0_ordered <- res_p7_v_p0[order(res_p7_v_p0$padj),]

res_p4_v_p0 <- results(dds_lrt, contrast = c( "timepoint", "vP4", "vP0" ), test='Wald')
res_p4_v_p0_ordered <- res_p4_v_p0[order(res_p4_v_p0$padj),]
```

```{r summary for p4 vs. p0, echo=FALSE, eval=FALSE}
summary(res_p4_v_p0_ordered)
```

```{r summary for p7 vs. p0, echo=FALSE, eval=FALSE}
summary(res_p7_v_p0_ordered)
```

## Extra exercises

- Extract out specific pairwise comparisons of interest across the time course (i.e. p4 vs p0)
- Use biomaRt to convert the ensembl gene ids to MGI symbols


::: {.box .note}
## References

<small>
**STAR**

Dobin A, Davis CA, Schlesinger F, Drenkow J, Zaleski C, Jha S, Batut P, Chaisson M, Gingeras TR. STAR: ultrafast universal RNA-seq aligner. Bioinformatics. 2013 Jan 1;29(1):15-21. doi: 10.1093/bioinformatics/bts635. Epub 2012 Oct 25. PMID: 23104886; PMCID: PMC3530905.

**VERSE**

Zhu, Q., Fisher, S.A., Shallcross, J., Kim, J. (Preprint). VERSE: a versatile and efficient RNA-Seq read counting tool. bioRxiv 053306.
doi: http://dx.doi.org/10.1101/053306

**GENCODE**

https://www.gencodegenes.org/mouse/
</small>
:::
