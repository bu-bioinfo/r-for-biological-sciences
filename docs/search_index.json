[["index.html", "R for Biological Sciences BF591 - R for Biological Sciences Course Schedule Course Values and Policies", " R for Biological Sciences BF591 - R for Biological Sciences Under construction Semester: Spring 2022 Location: NA Time: NA This course introduces the R programming language through the lens of practitioners in the biological sciences, particularly biology and bioinformatics. Key concepts and patterns of the language are covered, including: RStudio Data wrangling with tidyverse Data visualization with ggplot Essential biological data shapes and formats Core bioconductor packages Basic data exploration, including elementary statistical modeling and summarization “Toolifying” R scripts Communicating R code and results with RMarkdown Buidling R packages and unit testing strategies Building interactive tools with RShiny About 1/3 of the materials are inspired by the online textbook R for Data Science, while the rest has been developed by practicing bioinformaticians based on their experiences. Weekly programming assignments will help students apply these techniques to realistic problems involving analysis and visualization of biological data. Students will be introduced to a unit testing paradigm that will help them write correct code and deposit all their code into github for evaluation. The course materials are aligned with BF528 Applications in Translational Bioinformatics and are intended to be taken in tandem, but the materials also stand alone as an independent class. Course Schedule date leclink assignment 1/24 &amp; 1/26 Basics Your First Knitr 1/31 &amp; 2/2 Data Viz &amp; Exploration The Many Faces of PCA 2/7 &amp; 2/9 Data Wrangling Volcanos and Clustergrams 2/14 &amp; 2/16 Programming Count Distributions 2/22 &amp; 2/23 Biological Data Types Modular Differential Expression 2/28 &amp; 3/2 Data Viz 2 Visualizing Gene Networks NA Spring Break NA 3/14 &amp; 3/16 Data Exploration 2/Modeling TBD 3/21 &amp; 3/23 Core Bioconductor TBD 3/28 &amp; 3/30 Bioconductor Packages TBD 4/4 &amp; 4/6 Toolifying R Making a R Command Line Tool 4/11 &amp; 4/13 SoftwaRe EngineeRing Basic R Package 4/20 &amp; Communicating Results Standardized Pipeline Reports 4/25 &amp; 4/27 RShiny Interactive Analysis and Plotting 5/2 &amp; 5/4 Project work, no class NA Course Values and Policies Everyone is welcome. Every background, race, color, creed, religion, ethnic origin, age, sex, sexual orientation, gender identity, nationality is welcome and celebrated in this course. Everyone deserves respect, patience, and kindness. Disrespectful language, discrimination, or harassment of any kind are not tolerated, and may result in removal from class or the University. This is not merely BU policy. The instructors deem these principles to be inviolable human rights. Students should feel safe reporting any and all instances of discrimination or harassment to the instructor, to any of the Bioinformatics Program leadership, or the BU Equal Opportunity Office. Everyone brings value. Each of us brings unique experiences, skills, and creativity to this course. Our diversity is our greatest asset. Collaboration is highly encouraged. All students are encouraged to work together and seek out any and all available resources when completing projects in all aspects of the course, including sharing coding ideas and strategies with each other as well as those found on the internet. Any and all available resources may be brought to bear. However, consistent with BU policy, the bulk of your code and your final reports should be written in your own words and represent your own work and understanding of the material. Copying/pasting large sections of code is not acceptable and will be investigated as cheating (we check). A safe space for dissent. For complex topics such as those covered in this class, there is seldom one correct answer, approach, or solution. Disagreement fosters innovation. All in the course, including students and TAs, are encouraged to express constructive criticism and alternative ideas on any aspect of the content. We are always learning. Our knowledge and understanding is always incomplete. Even experts are fallible. The bioinformatics field evolves rapidly, and Rome was not built in a day. Be kind to yourself and to others. You are always smarter and more knowledgable today than you were yesterday. "],["preliminaries.html", "1 Preliminaries 1.1 RStudio 1.2 The R Script 1.3 git + github 1.4 Scripting workflow", " 1 Preliminaries 1.1 RStudio 1.2 The R Script 1.3 git + github 1.4 Scripting workflow "],["r-programming.html", "2 R Programming 2.1 Basics 2.2 Data Structures", " 2 R Programming 2.1 Basics 2.1.1 Overview 2.1.2 Learning Objectives 2.1.3 Skill List 2.1.4 R Syntax Basics 2.1.5 Functions 2.1.6 DRY: Don’t Repeat Yourself 2.1.7 Unit Testing 2.1.8 Troubleshooting/Debugging Strategies 2.1.9 RMarkdown &amp; knitr 2.2 Data Structures 2.2.1 Overview 2.2.2 Learning Objectives 2.2.3 Skill List "],["data-wrangling.html", "3 Data Wrangling 3.1 Basics 3.2 Data Types &amp; Relations 3.3 Part 3", " 3 Data Wrangling 3.1 Basics 3.1.1 Overview 3.1.2 Learning Objectives 3.1.3 Skill List 3.1.4 The Tidyverse 3.1.5 Importing Data 3.1.6 Tidying Data 3.1.7 Rectangular Data in Biology 3.2 Data Types &amp; Relations 3.2.1 Overview 3.2.2 Learning Objectives 3.2.3 Skill List 3.3 Part 3 3.3.1 Overview 3.3.2 Learning Objectives 3.3.3 Skill List "],["data-exploration.html", "4 Data Exploration 4.1 Part 1", " 4 Data Exploration 4.1 Part 1 4.1.1 Overview 4.1.2 Learning Objectives 4.1.3 Skill List "],["statistics-topics.html", "5 Statistics Topics 5.1 Distributions &amp; Tests 5.2 Modeling Primer", " 5 Statistics Topics 5.1 Distributions &amp; Tests 5.1.1 Overview 5.1.2 Learning Objectives 5.1.3 Skill List 5.2 Modeling Primer 5.2.1 Overview 5.2.2 Learning Objectives 5.2.3 Skill List "],["biology-bioinformatics.html", "6 Biology &amp; Bioinformatics 6.1 R in Biology 6.2 Gene Expression 6.3 Differential Expression: Microarrays 6.4 Differential Expression: Counts 6.5 Biological Network Analysis", " 6 Biology &amp; Bioinformatics 6.1 R in Biology 6.1.1 Overview 6.1.2 Learning Objectives 6.1.3 Skill List 6.1.4 Bioconductor 6.2 Gene Expression 6.2.1 Overview 6.2.2 Learning Objectives 6.2.3 Skill List 6.3 Differential Expression: Microarrays 6.3.1 Overview 6.3.2 Learning Objectives 6.3.3 Skill List 6.4 Differential Expression: Counts 6.4.1 Overview 6.4.2 Learning Objectives 6.4.3 Skill List 6.5 Biological Network Analysis 6.5.1 Overview 6.5.2 Learning Objectives 6.5.3 Skill List "],["data-visualization.html", "7 Data Visualization 7.1 Part 1 7.2 Part 2 7.3 Part 3", " 7 Data Visualization 7.1 Part 1 7.1.1 Overview 7.1.2 Learning Objectives 7.1.3 Skill List 7.2 Part 2 7.2.1 Overview 7.2.2 Learning Objectives 7.2.3 Skill List 7.3 Part 3 7.3.1 Overview 7.3.2 Learning Objectives 7.3.3 Skill List "],["engineering.html", "8 EngineeRing 8.1 Toolification 8.2 Parallel Processing 8.3 R Packages", " 8 EngineeRing 8.1 Toolification 8.1.1 Overview 8.1.2 Learning Objectives 8.1.3 Skill List 8.2 Parallel Processing 8.2.1 Overview Consider not using R for any legitimate development. 8.2.2 Learning Objectives 8.2.3 Skill List 8.3 R Packages 8.3.1 Overview 8.3.2 Learning Objectives 8.3.3 Skill List "],["rshiny.html", "9 RShiny 9.1 Overview 9.2 Learning Objectives 9.3 Skill List", " 9 RShiny 9.1 Overview 9.2 Learning Objectives 9.3 Skill List "],["communication.html", "10 Communication 10.1 Overview 10.2 Learning Objectives 10.3 Skill List", " 10 Communication 10.1 Overview 10.2 Learning Objectives 10.3 Skill List "],["assignment-2.html", "Assignment 2 Problem Statement Learning Objectives Skill List Instructions Function Details", " Assignment 2 Problem Statement Learning Objectives Skill List Instructions Our main focus for this assignment are installing packages, manipulating data, and plotting our manipulated data. We will be borrowing from the same started CSV of expression data from BF528’s Project 1, available here. The project is laid out as such: main.R test_main.R report.Rmd A skeleton of the functions you need to complete is in main.R. Tests have been pre-written to test your code and help you ensure it is running correctly, these are in test_main.R. Finally, we are also introducing the concept of R Markdown, which for this assignment is report.Rmd. The document itself goes into greater detail, but you will: 1. Complete the functions in main.R and use testthat:test_file('test_main.R') to ensure they work correctly. 2. Read the R Markdown file and complete the section called “Assignment”. To do this, you can source('main.R') to bring over the functions you wrote in step one. 3. Finally, annotate the functions you wrote and Knit the R Markdown report, complete with your additional comments and code execution. This page will go into detail on how the functions and their associated tests should work. Function Details 1. Bioconductor While many useful R packages can be loaded through CRAN using the install.packages() syntax, a lot of specifically bioinformatics packages are exclusively released on Bioconductor. For this assignment we only need the package called biomaRt. R programmers fancy themselves very clever, so Rs show up a lot. Naturally, we want to load our packages at the beginning of our script so all of the code we write beneath can access it as it runs. However, if a user or ourselves already has this package installed we don’t want to waste their time installing it again. The function require() can help us avoid unnecessary installation time and will help us develop faster. The Bioconductor link above has an example of this method. This section is untested. 2. load_expression() Perhaps the most integral part of using the many data wrangling abilities of R is actually entering your data into the R environment. While there are many ways to do this in R, we ultimately want this data to be in a tibble, which means the current form of the CSV will make R very angry if you attempt to load it in. This is because tibbles don’t support row names very well, and the first column of our data doesn’t have a name. Try to use the load_expression() data to load data from a filename parameter and return a tibble of that information. I called my firs column “probeids”. Tests The tests for this function are: test_that(&quot;loading csv correctly&quot;, { result_tib &lt;- load_expression(&quot;/project/bf528/project_1/data/example_intensity_data.csv&quot;) expect_equal(dim(result_tib), c(54675, 36)) expect_true(is_tibble(result_tib)) }) This test uses the load_expression() you write to store the returned tibble in result_tib. Heads up Note that this test is using the same file for data input as you are, but this may not always be the case. The test then compares the dimensions of that result, and expects 54,675 rows and 36 columns. These are the dimensions of the input CSV. It also checks to confirm it is a tibble object (because tibbles are better than dataframes). 3. filter_15() In order to filter the numerous rows we have for this data, we introduce a function that filters the probe IDs in the tibble our data is stored in. We want to capture probes that have a suitably high level of expression, so we are setting log2(15) as the cutoff for an expression level. We will keep a row if 15% of the values in that row exceed log2(15) (about 3.9). Since we may want to examine the probe IDs we find, the function simple returns the values of the probe IDs (column 1) instead of returning the entire tibble. This function presents an important concept in R: using built-ins to speed up our code. Built-ins are functions and packages that are optimized to process data in a certain way. Since we’re looking at each row of a table, we could simply use a for loop to iterate one row at a time. This is slow, though, and for this function might take 5-10 seconds to run (a long time for a program like this!). Instead, you could use a function like apply() or lapply() to filter every row at once. This solution takes mere moments. Tests library(tibble) test_that(&quot;the correct rows are filtered out in filter_15()&quot;, { test_tib &lt;- tibble(probeids=c(&#39;1_s_at&#39;, &#39;2_s_at&#39;, &#39;3_s_at&#39;, &#39;4_s_at&#39;), GSM1=c(1.0, 3.95, 4.05, 0.5), GSM2=rep(1.6, 4), GSM3=rep(2.5, 4), GSM4=rep(3.99, 4), GSM5=rep(3.0, 4), GSM6=rep(1.0, 4), GSM7=rep(0.5, 4)) expect_equal(pull(filter_15(test_tib)), c(&quot;2_s_at&quot;, &quot;3_s_at&quot;)) }) In order to test this function, we create a small sample tibble of expression data containing only seven samples and four IDs. Two of the rows do have more than 15% of their values exceeding log2(15), the other two do not. This test ensures that filter_15() selects the correct rows. Creating a small sample table like this can be very useful when testing your own code since you don’t need to look at a large amount of data to see if it’s working correctly or not. 4. affy_to_hgnc() This is an important, but sometimes painful, part of using R. There is a great built-in package for connecting to Ensembl (a database of genomic information for many species) called biomaRt. We will use biomaRt to connect the affymetrix probe IDs to more recognizable HGNC gene IDs. The problem is that biomaRt depends on an external API (application program interface) to retrieve data, and this connection sometimes (oftentimes) doesn’t work. While their may be more nuanced approaches to an unstable resource like this like automatically retrying failed connections, the best advice for the time being is to try running this function a few times if it doesn’t work at first. The errors are clear when it comes to a failed connection, so know that when you get to this stage it likely isn’t your code’s fault. To build a biomaRt query, read the documentation in section 3 here. The biomart you should use is ENSEMBL_MART_ENSEMBL, the data set hsapiens_gene_ensembl, and you want to find the attributes c(\"affy_hg_u133_plus_2\", \"hgnc_symbol\"). The data you filter using filter_15() returns a list of affy_hg_u133_plus_2 probe IDs, and the gene names we’re interested in are stored in hgnc_symbol. This function should return a tibble, but biomaRt’s getBM() will only accept and return a data.frame. You can use dplyr::pull() to turn a tibble into a simple character vector, and dplyr::as_tibble() to go from a data frame to a tibble. Tests test_that(&quot;affy ids can be converted to HGNC names properly using affy_to_hgnc()&quot;, { # biomaRt super buggy so we can try to account for not connecting well response &lt;- try(affy_to_hgnc(tibble(&#39;1553551_s_at&#39;)), TRUE) if (grepl(&quot;Error&quot;, response[1])) { expect_warning(warning(&quot;Could not connect to ENSEMBL.&quot;)) } else { expect_equal(response$hgnc_symbol, c(&quot;MT-ND1&quot;, &quot;MT-TI&quot;, &quot;MT-TM&quot;, &quot;MT-ND2&quot;)) } }) As fun as it is to try to get biomaRt function to connect correctly, it is even more fun to test them. Since a failure to connect doesn’t indicate an actual failure in our code we must use a try() block in order to capture if there is a connection error. Note The try() function is a part of programming called error-handling which extends to many other languages. We often expect errors when running our programs (such as right now) but don’t want to shut down our entire operation if it’s an error we can expect. Using try, except, and finally (the latter two not appearing here) we can account for issues outside of our control and adapt our code to change the outcome. Using try except is not a replacement for writing code that doesn’t generate errors. If you can avoid an error in the first place, that is far better than using error-handling. In this case we try() to use affy_to_hgnc() to connect to Ensembl and store the resulting error in response. We then check: if there is an “Error” then we throw a warning() to our testing output. This doesn’t stop further testing from happening, but it ensures we know that something isn’t quite right. If the response does not contain an error, we simply test that it returned the correct gene symbols for our random affy probe ID of choice. 5. reduce_data() We have one final step in manipulating our data before we plot it. We have our original data, the probe IDs and their associated HGNC symbols, and a list of good gene names and bad gene names. reduce_data takes these four inputs and returns a tibble that has reduced our expression data to only the genes of interest and has a column describing which set of genes it belongs to (“good” or “bad”). Changing the shape of the data is incredibly useful for ggplot, the tidyverse package we will use for plotting. While there is flexibility when using ggplot to plot data, having data in long format is typically ideal. Once again, there are multiple ways to reorganize data in this way. We used the base function match() to connect our probe IDs to with our HGNC IDs in name_ids. We then used tibble::add_column() to insert the new data in the correct location. Finally, we created two tibbles of good and bad genes using which() and the %in% modifier. Which evaluates true conditions across a range of data, so we can pass the list of genes we want and select the correct ones. For instance: library(tibble) tib &lt;- tibble(gene = c(&quot;gene1&quot;, &quot;gene2&quot;, &quot;gene3&quot;, &quot;gene4&quot;), affy = c(&quot;a_s_1&quot;, &quot;a_s_2&quot;, &quot;a_s_3&quot;, &quot;a_s_4&quot;)) which(tib$gene %in% c(&quot;gene2&quot;, &quot;gene3&quot;)) # returns the index of the TRUE rows ## [1] 2 3 tib$affy[which(tib$gene %in% c(&quot;gene2&quot;, &quot;gene3&quot;))] # use [] to get data back ## [1] &quot;a_s_2&quot; &quot;a_s_3&quot; Once again, there are many ways to reshape this data (some maybe more elegant than this!) and all we need is the data to be correctly shaped when it is returned. Tests test_that(&quot;reduce_data() is correctly changing the size and shape of the tibble&quot;, { t_tibble &lt;- tibble(probeids = c(&quot;1_s_at&quot;, &quot;2_s_at&quot;, &quot;3_s_at&quot;), GSM1 = c(9.5, 7.6, 5.5), GSM2 = c(9.7, 7.2, 2.9), GSM3 = c(6.9, 4.3, 6.8)) names &lt;- tibble(affy_hg_u133_plus_2 = c(&quot;1_s_at&quot;, &quot;2_s_at&quot;, &quot;3_s_at&quot;), hgnc_symbol = c(&quot;A-REAL-GENE&quot;, &quot;SONIC&quot;, &quot;UTWPU&quot;)) good &lt;- c(&quot;A-REAL-GENE&quot;) bad &lt;- c(&quot;SONIC&quot;) reduce_test &lt;- reduce_data(t_tibble, names, good, bad) result &lt;- tibble(probeids = c(&quot;1_s_at&quot;, &quot;2_s_at&quot;), hgnc_symbol = c(&quot;A-REAL-GENE&quot;, &quot;SONIC&quot;), gene_set = c(&quot;good&quot;, &quot;bad&quot;), GSM1 = c(9.5, 7.6), GSM2 = c(9.7, 7.2), GSM3 = c(6.9, 4.3)) expect_equal(reduce_test, result) }) In order to test a function that changes a tibble, we need to use a tibble. We only create a test table that is three rows by four columns, but that is enough to get the gist of the function. We simply pass the four parameters to reduce_data() and we expect it to create a tibble like result. Ensure your output column names are the same here or your tests my fail. While not crucial to the success of your assingment, maintaining correct column names across multiple data transformations is an important skill. "],["assignment-6.html", "Assignment 6 Problem Statement Learning Objectives Skill List", " Assignment 6 Problem Statement Plotting data is a useful but oftentimes complicated skill set. While R has many tools to help simplify and create attractive and useful graphs, they can be difficult to utilize and have many pitfalls. This assignment will teach you the most important parts of plotting with R using the package ggplot. Learning Objectives The basic operations of ggplot and “The Grammar of Graphics”. Using differential gene expression analysis packages to generate data for plotting. Creating simple plots and not using the default colors and themes. Combining multiple plots into one image. Skill List A tempered heart and mind that understands a plot may not ever look exactly how you want it to. An intermediate understanding of R’s most popular plotting package, ggplot. Further understanding of differential expression analysis and its plotting. A sense of superiority whenever you see a publication use the base R plotting package for figures. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
